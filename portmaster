#!/bin/sh

# Copyright (c) 2005-2011 Douglas Barton, All rights reserved
# Please see detailed copyright below

trap trap_exit INT

# Initialize crucial values for the parent, and export them for the children
if [ -z "$PM_PARENT_PID" ]; then
	PM_PARENT_PID=$$
	: ${TMPDIR:=/tmp}
	UPGRADE_TOOL=portmaster

	# /usr/local is needed in the path for make
	PATH=/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/local/sbin
	[ -e /usr/X11R6 -a ! -L /usr/X11R6 ] && PATH=$PATH:/usr/X11R6/bin
	[ -n "$CCACHE_PATH" -a -z "$NOCCACHE" ] && PATH="/usr/local/libexec/ccache:$PATH"
	export PM_PARENT_PID TMPDIR UPGRADE_TOOL PATH

	if [ -r /etc/portmaster.rc ]; then
		echo '' ; echo "===>>> WARNING"
		echo '       Your portmaster.rc is in /etc, however support for the file in this'
		echo '       location has been removed.'
		echo '' ; echo '       The proper location for this file is /usr/local/etc'
		exit 1
	fi

	set -o allexport
	# Read a global rc file first
	[ -r /usr/local/etc/portmaster.rc ] && . /usr/local/etc/portmaster.rc

	# Read a local one next, and allow the command line to override
	[ -r "$HOME/.portmasterrc" ] && . $HOME/.portmasterrc
	set +o allexport

	my_environment=`set`

	# If we are already root, unset this to avoid potential conflict
	euid=`ps -o uid $$` ; euid=${euid##* }
	[ "$euid" -eq 0 ] && unset PM_SU_CMD PM_SU_VERBOSE
	unset euid
fi

umask 022

#=============== Begin functions we always want to have ===============

version () {
	local svn

	svn='$FreeBSD$'

	svn="${svn#*,v }" ; svn="${svn#*/portmaster }" ; svn="${svn%% *}"

	echo ''
	[ "${svn#$}" != 'FreeBSD$' ] && { echo "===>>> Version $svn" ; return 0; }
	echo "===>>> Version unknown!"
}

fail () {
	echo '' ; echo "===>>> $*" ; echo "===>>> Aborting update"
	[ "$$" -eq "$PM_PARENT_PID" ] && trap_exit fail
	safe_exit 1
}

trap_exit () {
	echo ''		# Helps if the previous message was 'echo -n'
	if [ -n "$portdir" -a -z "$1" ]; then
		echo "===>>> Build/Install for $portdir exiting due to signal"
	elif [ -z "$1" ]; then
		echo "===>>> Exiting due to signal"
	fi

	if [ "$$" -eq "$PM_PARENT_PID" ]; then
		local n=0
		while ps -axo pid,ppid,command | grep -v egrep |
		    egrep -q "(make -DBATCH checksum|/fetch |\[sh\])"; do
			# Protect from infinite loop if there is another fetch
			[ $n -gt 9 ] && break
			n=$(( $n + 1 ))
			kill_bad_children
		done
		if [ -n "$HIDE_BUILD" ]; then
			local logs file
			logs=`echo ${TMPDIR}/port_log-${PM_PARENT_PID}-*`
			case "$logs" in *\*) unset logs ;; esac
			if [ -n "$logs" ]; then
				echo ''
				echo "===>>> Build/Install logs available:"
				for file in $logs; do echo "	$file"; done
			fi
			[ -n "$logs" ] && echo ''
		fi
	fi
	safe_exit 1
}

kill_bad_children () {
	local mypgid pid ppid pgid command ; IFS=' '

	mypgid=`ps -o pgid -p $PM_PARENT_PID` ; mypgid=${mypgid##*PGID[^0-9]}

	ps -axo pid,ppid,pgid,command | sed '1d' | while read pid ppid pgid command; do
		[ "$pid" -gt 25 ] || continue
		case "$ppid" in
		1)	case "$command" in
			*" $0 "*) pm_kill $pid ;;
			*'make -DBATCH checksum'*|*'/fetch '*|\[sh\]) pm_kill -9 $pid ;;
			esac ;;
		*)	[ $pgid -eq $mypgid ] || continue
			case "$command" in
			*" $0 "*) [ $pid -ne $PM_PARENT_PID ] && pm_kill $pid ;;
			*'make -DBATCH checksum'*|*'/fetch '*|\[sh\]) pm_kill $pid ;;
			esac ;;
		esac
	done
}

parent_exit () {
	local files f DISCARD show_list

	[ -s "$DI_FILES" ] && { grep -q '%%%%%%%%%%%%' $DI_FILES || kill_bad_children; }

	[ -n "$FETCH_ONLY" -a -z "$FETCH_ONLY_DONE" ] && kill_bad_children

	if [ -z "$1" ]; then
		if [ -n "$UPDATE_REQ_BYS" -o -n "$PM_FORCE" ]; then
			files=`find $pdb -type f -name PM_UPGRADE_DONE_FLAG`
			if [ -n "$files" ]; then
				pm_sv Deleting \'install complete\' flags
				pm_find_s $pdb -type f -name PM_UPGRADE_DONE_FLAG -delete
			fi
		fi
		if [ -z "$BACKUP" -a -z "$NO_BACKUP" -a -n "$NB_DELETE" ]; then
			pm_sv 'Deleting safety packages for successful installs'
			pm_cd $pbu || fail "Cannot cd to $pbu"
			pm_rm_s $NB_DELETE
		fi
	fi

	[ -n "$pbu" ] && pbu=`find $pbu -type d -empty 2>/dev/null`
	if [ -d "$pbu" ]; then
		pm_sv 'Removing empty backup package directory'
		pm_rmdir_s $pbu
	fi

	for f in ${TMPDIR}/f-${PM_PARENT_PID}-*; do pm_unlink $f ; done

	[ -n "$PM_WRKDIRPREFIX" ] &&
		find -d $PM_WRKDIRPREFIX -mindepth 1 -type d -empty -delete 2>/dev/null

	case "$DISPLAY_LIST" in
	*' '*)	if [ -n "$1" ]; then
			echo "===>>> There are messages from installed ports to display,"
			echo "       but first take a moment to review the error messages"
			echo -n "       above.  Then press Enter when ready to proceed. "
			read DISCARD
			echo ''
		fi

		: ${PAGER:='less -e'}
		( for f in $DISPLAY_LIST; do
			echo "===>>> pkg-message for $f" ; cat $pdb/$f/+DISPLAY ; echo ''
		done
		echo "===>>> Done displaying pkg-message files" ; echo '' ) | $PAGER ;;
	esac

	if [ -n "$INSTALLED_LIST" ]; then
		if [ -n "$UPDATE_ALL" -o -n "$PM_MULTI_PORTS" ]; then
			show_list=all
		else
			case "$INSTALLED_LIST" in
			*\\n\\t*)	show_list=all ;;
			*\\n)		show_list=one
					if [ -z "$ilist" ]; then
						ilist="${INSTALLED_LIST#\\t}"
						ilist="${ilist%\\n}"
					fi ;;
			esac
		fi
		if [ -n "$PM_LOG" ]; then
			if [ -w "$PM_LOG" ]; then
				echo '' >> $PM_LOG
			elif [ -e "$PM_LOG" -a ! -w "$PM_LOG" ]; then
				echo "===>>> Warning: $PM_LOG exists, but is not writable"
				unset PM_LOG
			elif [ -e "$PM_LOG" -o -L "$PM_LOG" ]; then
				echo "===>>> Warning: $PM_LOG exists, but is not a regular file"
				unset PM_LOG
			else
				local new_pm_log

				new_pm_log=`pm_mktemp pm_log` && mv $new_pm_log $PM_LOG
			fi
			[ -n "$PM_LOG" ] && date >> $PM_LOG
		fi
		[ -n "$PM_SU_VERBOSE" ] && echo ''
		case "$show_list" in
		all)	echo "===>>> The following actions were performed:"
			echo -e $INSTALLED_LIST
			[ -n "$PM_LOG" ] && echo -e ${INSTALLED_LIST%\\n} >> $PM_LOG ;;
		one)	echo "===>>> $ilist complete" ; echo ''
			[ -n "$PM_LOG" ] && echo "	$ilist" >> $PM_LOG ;;
		esac
	fi

	if [ -n "$build_deps_il" ]; then
		echo "===>>> Deleting installed build-only dependencies"
		cd
		for f in $build_deps_il; do
			pm_v "       $f"
			pm_pkg_delete_s -f $f
		done
		echo ''
	fi

	PM_NEEDS_UPDATE=${PM_NEEDS_UPDATE# }
	if [ -n "$1" -a -n "$PM_NEEDS_UPDATE" -a -n "$PM_BUILDING" ]; then
		echo ''
		echo "===>>> You can restart from the point of failure with this command line:"
		echo "       ${0##*/} <flags> $PM_NEEDS_UPDATE"
		echo ''
	fi
}

safe_exit () {
	if [ "$$" -eq "$PM_PARENT_PID" ]; then
		parent_exit $1
	else
		[ -n "$grep_deps" ] && pm_unlink $grep_deps

		[ -n "$1" ] && exit $1

		# Save state for the parent process to read back in
		if [ -z "$PM_FIRST_PASS" ]; then
			> $IPC_SAVE
			echo "DISPLAY_LIST='$DISPLAY_LIST'" >> $IPC_SAVE
			echo "INSTALLED_LIST='$INSTALLED_LIST'" >> $IPC_SAVE

			[ -n "$PM_DEL_BUILD_ONLY" ] &&
				echo "build_deps_il='$build_deps_il'" >> $IPC_SAVE

			for i in $PM_NEEDS_UPDATE; do
				[ "$i" = "$portdir" ] && continue
				pnu_temp="${pnu_temp}${i} "
			done

			PM_NEEDS_UPDATE=" ${pnu_temp}"
		else
			# Do these here so +IGNOREME can modify them
			echo "num_of_deps='$num_of_deps'" >> $IPC_SAVE
			echo "build_l='$build_l'" >> $IPC_SAVE
			[ -z "$NO_DEP_UPDATES" ] && echo 'unset NO_DEP_UPDATES' >> $IPC_SAVE
		fi
		echo "CUR_DEPS='$CUR_DEPS'" >> $IPC_SAVE
		echo "dep_of_deps='$dep_of_deps'" >> $IPC_SAVE
		echo "PM_NEEDS_UPDATE='$PM_NEEDS_UPDATE'" >> $IPC_SAVE
		[ -z "$NO_BACKUP" -a -z "$BACKUP" ] && echo "NB_DELETE='$NB_DELETE'" >> $IPC_SAVE
		if [ -n "$INTERACTIVE_UPDATE" ]; then
			echo "INTERACTIVE_YES='$INTERACTIVE_YES'" >> $IPC_SAVE
			echo "INTERACTIVE_NO='$INTERACTIVE_NO'" >> $IPC_SAVE
		fi
		[ -n "$URB_YES" ] && echo "URB_DONE_LIST='$URB_DONE_LIST'" >> $IPC_SAVE
	fi

	exit ${1:-0}
}

pm_cd     () { builtin cd $1 2>/dev/null || return 1; }
pm_cd_pd  () { [ -n "$PM_INDEX_ONLY" ] && return 2;
		builtin cd $pd/$1 2>/dev/null ||
		fail "Cannot cd to port directory: $pd/$1"; }
pm_kill   () { /bin/kill $* >/dev/null 2>/dev/null; }
pm_make   () { ( unset -v CUR_DEPS INSTALLED_LIST PM_DEPTH build_l;
		 unset -v MASTER_RB_LIST;
		 /usr/bin/nice /usr/bin/make $PM_MAKE_ARGS $*; ); }
pm_make_b () { /usr/bin/make $PM_MAKE_ARGS BEFOREPORTMK=bpm $*; }
pm_mktemp () { /usr/bin/mktemp -t f-${PM_PARENT_PID}-$1 ||
		fail "mktemp for $1 failed"; }
pm_unlink () { /bin/test -e $1 && /bin/unlink $1; }

# Superuser versions for commands that need root privileges

pm_find_s         () { $PM_SU_CMD /usr/bin/find $*; }
pm_install_s      () { $PM_SU_CMD /usr/bin/install -o root -g wheel -m 644 $1 $2; }
pm_make_s         () { ( unset -v CUR_DEPS INSTALLED_LIST PM_DEPTH build_l;
			 unset -v MASTER_RB_LIST;
			 $PM_SU_CMD /usr/bin/nice /usr/bin/make $PM_MAKE_ARGS $*; ); }
pm_mkdir_s        () { $PM_SU_CMD /bin/mkdir -p $1; }
pm_pkg_delete_s   () { $PM_SU_CMD /usr/sbin/pkg_delete $*; }
pm_rm_s           () { $PM_SU_CMD /bin/rm $*; }
pm_rmdir_s        () { $PM_SU_CMD /bin/rmdir $*; }
pm_unlink_s       () { /bin/test -e $1 && $PM_SU_CMD /bin/unlink $1; }

pm_v              () { [ -n "$PM_VERBOSE" ] && echo "$*"; }
pm_sv             () { [ -n "$PM_SU_VERBOSE" ] && echo "===>>> SU $*"; }

# Do this here so we can have a reasonably good guess.
# May be modified below.
if [ "$$" -eq "$PM_PARENT_PID" ]; then
	if [ -z "$pd" ]; then
		if [ -z "$PORTSDIR" ]; then
			[ -d /usr/ports ] && pd=/usr/ports
			[ -z "$pd" ] &&
				pd=`pm_make_b -f/usr/share/mk/bsd.port.mk -V PORTSDIR 2>/dev/null`
		else
			pd=$PORTSDIR
		fi
	fi
	if [ -n "$pd" ]; then
		[ ! -r "${pd}/Mk/bsd.port.mk" ] &&
			fail "The ports directory ($pd) does not seem to contain a ports tree"
		export pd
	fi

	if [ -z "$pdb" ]; then
		if [ -z "$PKG_DBDIR" ]; then
			[ -d /var/db/pkg ] && pdb=/var/db/pkg
			[ -z "$pdb" ] &&
				pdb=`pm_make -f/usr/share/mk/bsd.port.mk -V PKG_DBDIR 2>/dev/null`
		else
			pdb=$PKG_DBDIR
		fi
		if [ -z "$pdb" ]; then
			if [ -d /var/db/pkg ]; then
				pdb='/var/db/pkg'
			else
				fail 'The value of PKG_DBDIR cannot be empty'
			fi
		fi
	fi
	export pdb

	[ -z "$port_dbdir" -a -d /var/db/ports ] && port_dbdir=/var/db/ports
	[ -z "$port_dbdir" ] &&
		port_dbdir=`pm_make_b -f/usr/share/mk/bsd.port.mk -V PORT_DBDIR 2>/dev/null`
	[ -n "$port_dbdir" ] && export port_dbdir
fi

usage () {
	local pd pdb port_dbdir

	[ -z "$pd" ] && pd=/usr/ports
	[ -z "$pdb" ] && pdb=/var/db/pkg
	[ -z "$port_dbdir" ] && port_dbdir=/var/db/ports

	version
	echo ''
	echo 'Usage:'
	echo "Common flags: [--force-config] [-CGHKgntvw B|b f|i D|d]"
	echo "    [[[--packages|-P]|[--packages-only|-PP]] | [--packages-build]]"
	echo "    [--packages-if-newer] [--delete-build-only] [--always-fetch]"
	echo "    [--local-packagedir=<path>] [--packages-local] [--delete-packages]"
	echo "    [--no-confirm] [--no-term-title] [--no-index-fetch]"
	echo "    [--index|--index-first|--index-only]"
	echo "    [-m <arguments for make>] [-x <glob pattern to exclude from building>]"
	echo "${0##*/} [Common flags] <full name of port directory in $pdb>"
	echo "${0##*/} [Common flags] <full path to $pd/foo/bar>"
	echo "${0##*/} [Common flags] <glob pattern of directories in $pdb>"
	echo "${0##*/} [Common flags] Multiple full names/paths from $pdb|$pd"
	echo "                          and/or multiple globs from $pdb"
	echo ''
	echo "${0##*/} [Common flags] . [Use in $pd/foo/bar to build that port]"
	echo ''
	echo "${0##*/} --show-work [-Gv] [-m <args>] <single port, as above>"
	echo ''
	echo "${0##*/} [Common flags] -o <new port dir in $pd> <installed port>"
	echo "${0##*/} [Common flags] [-R] -r <name/glob of port directory in $pdb>"
	echo ''
	echo "${0##*/} [Common flags] -a"
	echo ''
	echo "${0##*/} -[l|L]"
	echo ''
	echo "${0##*/} --list-origins"
	echo ''
	echo "${0##*/} [--force-config|-G] [-aftv] -F"
	echo ''
	echo "${0##*/} [-n|y] [-b D|d] -e <name/glob of a single port directory in $pdb>"
	echo "${0##*/} [-n|y] [-b D|d] -s"
	echo ''
	echo "${0##*/} [-n|y] [-t] --clean-distfiles"
	echo ''
	echo "${0##*/} [-n|y] [--index|--index-only] --clean-packages"
	echo ''
	echo "${0##*/} [-n|y] --check-depends"
	echo ''
	echo "${0##*/} [-n|y] [-v] --check-port-dbdir"
	echo ''
	echo "${0##*/} -h|--help"
	echo "${0##*/} --version"
	echo ''
	echo "--force-config 'make config' for all ports (overrides -G)"
	echo "-C prevents 'make clean' from being run before building"
	echo "-G prevents 'make config'"
	echo "-H hide details of the port build and install in a log file"
	echo "-K prevents 'make clean' from being run after building"
	echo '-B prevents creation of the backup package for the installed port'
	echo '-b create and keep a backup package of an installed port'
	echo '-g create a package of the new port'
	echo '-n run through all steps, but do not make or install any ports'
	echo '-t recurse dependencies thoroughly, using all-depends-list'
	echo '-v verbose output'
	echo '-w save old shared libraries before deinstall'
	echo '[-R] -f always rebuild ports (overrides -i)'
	echo '-i interactive update -- ask whether to rebuild ports'
	echo '-D no cleaning of distfiles'
	echo '-d always clean distfiles'
	echo "-m <arguments for the 'make' command line>"
	echo "-x <avoid building or updating ports that match this pattern>"
	echo '   Can be specified more than once'
	echo ''
	echo '--no-confirm do not ask user to confirm list of ports to be'
	echo '   installed and/or updated before proceeding'
	echo '--no-term-title do not update the xterm title bar'
	echo ''
	echo '--no-index-fetch skip fetching the INDEX file'
	echo '--index use INDEX-[6-9] exclusively to check if a port is up to date'
	echo '--index-first use the INDEX for status, but double-check with the port'
	echo '--index-only do not try to use /usr/ports'
	echo ''
	echo '--show-work list what ports are and would be installed'
	echo ''
	echo '-o replace the installed port with a port from a different origin'
	echo '[-R] -r rebuild port, and all ports that depend on it'
	echo '-R used with -[rf] to skip ports updated on a previous run'
	echo ''
	echo '-a check all ports, update as necessary'
	echo ''
	echo '--delete-build-only delete ports that are build-only dependencies'
	echo '   after a successful run, only if installed this run'
	echo ''
	echo '-P|--packages use packages, but build port if not available'
	echo '-PP|--packages-only fail if no package is available'
	echo '--packages-build use packages for all build dependencies'
	echo '--packages-if-newer use package if newer than installed even'
	echo '   if the package is not the latest according to the ports tree'
	echo '--always-fetch fetch package even if it already exists locally'
	echo '--local-packagedir=<path> where local packages can be found,'
	echo '   will fall back to fetching if no local version exists'
	echo '--packages-local use packages from --local-packagedir only'
	echo '--delete-packages after installing from a package, delete it'
	echo ''
	echo '-l list installed ports by category'
	echo '-L list installed ports by category, and search for updates'
	echo ''
	echo "--list-origins list directories from $pd for root and leaf ports"
	echo ''
	echo '[--force-config|-G] [-aftv] -F fetch distfiles only'
	echo ''
	echo '-e expunge a single port via pkg_delete, and remove its distfiles'
	echo '-s clean out stale ports that used to be depended on'
	echo ''
	echo '[-t] --clean-distfiles offer to delete stale distfiles'
	echo '[-t] -y --clean-distfiles delete stale distfiles without prompting'
	echo '   with -t distfile is valid from any port, not just those installed'
	echo ''
	echo '[--index|--index-only] --clean-packages offer to delete stale packages'
	echo '[--index|--index-only] -y --clean-packages delete without prompting'
	echo '   --index-only is required if no ports tree is available'
	echo ''
	echo '--check-depends cross-check and update dependency information for all ports'
	echo ''
	echo "--check-port-dbdir [-v] check for stale entries in $port_dbdir"
	echo ''
	echo '-h|--help display this help message'
	echo '--version display the version number'
	echo ''
	echo 'Please see the portmaster(8) man page for more information'
	safe_exit ${1:-1}
}

globstrip () { local in ; in=${1%[*]} ; in=${in%\\} ; echo $in ; }

# Takes a pattern as input
# Return values:
# 0 - Matched one and only one directory in $pdb
# 1 - No match
# 2 - Matched multiple directories
#
find_glob_dirs () {
	# Global: glob_dirs
	local pattern

	pattern=`globstrip $1`

	glob_dirs=`find $pdb -maxdepth 1 -type d -name ${pattern}\*`
	case "$glob_dirs" in
	# Match a newline in multiple responses from find
	*'
'*)		return 2 ;;
	$pdb/*)	return ;;
	esac

	unset glob_dirs
	return 1
}

origin_from_pdb () {
	local o

	o=`grep -m1 '@comment ORIGIN:' $pdb/$1/+CONTENTS 2>/dev/null` && {
		echo ${o#@comment ORIGIN:}; return 0; }

	case "$1" in bsdpan-*) return 3 ;; esac

	if [ -e "$pdb/$1/+IGNOREME" ]; then
		if [ -n "$PM_VERBOSE" -o -n "$LIST_ORIGINS" ]; then
			echo "	===>>> No ORIGIN in $pdb/$1/+CONTENTS" >&2
			echo "	===>>> $pdb/$1/+IGNOREME exists" >&2
			echo '' >&2
		fi
		return 2
	else
		echo "	===>>> No ORIGIN in $pdb/$1/+CONTENTS" >&2
		echo '' >&2
	fi
	return 1
}

#=============== End functions we always want to have ===============
#=============== Begin Command Line Option Processing ===============

packages_init () {
	local e1 e2 e3

	e1="The -P/--packages and -PP/--packages-only options are mutually exclusive"
	e2="The --packages-build option and the -P[P] options are mutually exclusive"
	e3="The --packages-if-newer and -PP/--packages-only options are mutually exclusive"

	case "$1" in
	first)	[ "$PM_PACKAGES" = only ] && fail $e1
		[ -n "$PM_PACKAGES_BUILD" ] && fail $e2
		[ -z "$PM_PACKAGES" ] && { PM_PACKAGES=first ; export PM_PACKAGES; } ;;
	only)	[ "$PM_PACKAGES" = first ] && fail $e1
		[ "$PM_PACKAGES" = newer ] && fail $e3
		[ -n "$PM_PACKAGES_BUILD" ] && fail $e2 ;;
	build)	case "$PM_PACKAGES" in first|only) fail $e2 ;; esac ;;
	newer)	[ "$PM_PACKAGES" = only ] && fail $e3
		[ -z "$PM_PACKAGES" -a -z "$PM_PACKAGES_BUILD" ] && {
			PM_PACKAGES=newer ; export PM_PACKAGES; } ;;
	local)	[ -z "$PM_PACKAGES" -a -z "$PM_PACKAGES_BUILD" ] && {
			PM_PACKAGES=local ; export PM_PACKAGES; } ;;
	esac
}

cross_idx () {
	local e1

	e1='The --index, --index-first, and --index-only options are mutually exclusive'

	case "$1" in
	index)		[ -n "$PM_INDEX_FIRST" -o -n "$PM_INDEX_ONLY" ] && fail $e1 ;;
	first)		[ -n "$PM_INDEX" -o -n "$PM_INDEX_ONLY" ] && fail $e1 ;;
	only)		[ -n "$PM_INDEX" -o -n "$PM_INDEX_FIRST" ] && fail $e1 ;;
	esac
}

for var in "$@" ; do
	case "$var" in
	-PP[A-Za-z0-9]*|-*[A-Za-z0-9]PP*)
				fail "The -PP option must stand alone" ;;
	--packages)		packages_init first ;;
	-PP|--packages-only)	packages_init only
				PM_PACKAGES=only ; export PM_PACKAGES ;;
	--packages-build)	packages_init build
				unset PM_PACKAGES
				PM_PACKAGES_BUILD=pmp_build
				export PM_PACKAGES_BUILD ;;
	--packages-if-newer)	packages_init newer
				PM_PACKAGES_NEWER=pmp_newer
				export PM_PACKAGES_NEWER ;;
	--packages-local)	packages_init local
				PM_PACKAGES_LOCAL=pmp_local
				export PM_PACKAGES_LOCAL ;;
	--always-fetch)		PM_ALWAYS_FETCH=pm_always_fetch
				export PM_ALWAYS_FETCH ;;
	--local-packagedir=*)	LOCAL_PACKAGEDIR=${var#--local-packagedir=}
				export LOCAL_PACKAGEDIR ;;
	--delete-packages)	PM_DELETE_PACKAGES=pm_delete_packages
				export PM_DELETE_PACKAGES ;;
	-[A-Za-z0-9]*)		newopts="$newopts $var" ;;
	--delete-build-only)	PM_DEL_BUILD_ONLY=pm_dbo
				export PM_DEL_BUILD_ONLY ;;
	--no-confirm)		PM_NO_CONFIRM=pm_no_confirm
				export PM_NO_CONFIRM ;;
	--no-term-title)	PM_NO_TERM_TITLE=pm_no_term_title
				export PM_NO_TERM_TITLE ;;
	--no-index-fetch)	PM_NO_INDEX_FETCH=pm_no_index_fetch ;;
	--index)		cross_idx index ; PM_INDEX=pm_index ; export PM_INDEX ;;
	--index-first)		cross_idx first ; PM_INDEX=pm_index
				PM_INDEX_FIRST=pm_index_first
				export PM_INDEX PM_INDEX_FIRST ;;
	--index-only)		cross_idx only ; PM_INDEX=pm_index
				PM_INDEX_ONLY=pm_index_only
				export PM_INDEX PM_INDEX_ONLY ;;
	--help)			usage 0 ;;
	--version)		version ; exit 0 ;;
	--clean-distfiles)	CLEAN_DISTFILES=clean_distfiles ;;
	--clean-distfiles-all)	echo "===>>> The -all form is deprecated, please use -y instead"
				CLEAN_DISTFILES=clean_distfiles ; PM_YES=yopt ;;
	--clean-packages)	CLEAN_PACKAGES=clean_packages ;;
	--clean-packages-all)	echo "===>>> The -all form is deprecated, please use -y instead"
				CLEAN_PACKAGES=clean_packages ; PM_YES=yopt ;;
	--check-depends)	CHECK_DEPENDS=check_depends ;;
	--check-port-dbdir)	CHECK_PORT_DBDIR=check_port_dbdir ;;
	--list-origins)		LIST_ORIGINS=list_origins ;;
	--show-work)		SHOW_WORK=show ; RECURSE_THOROUGH=thorough ;;
	--force-config)		export PM_FORCE_CONFIG=pm_force_config ;;
	--*)			echo "Illegal option $var" ; echo ''
				echo "===>>> Try ${0##*/} --help"; exit 1 ;;
	*)			newopts="$newopts $var" ;;
	esac
done

[ -n "$PM_INDEX" -a -n "$CHECK_PORT_DBDIR" ] &&
	fail 'The --index* and --check-port-dbdir options are mutually exclusive'

[ -n "$PM_PACKAGES_LOCAL" -a -z "$LOCAL_PACKAGEDIR" ] &&
	fail 'The --packages-local option requires --local-packagedir to be defined'

set -- $newopts
unset var newopts

# Save switches for potential child processes
while getopts 'BCDFGHKLPRabde:fghilm:nop:r:stuvwx:y' COMMAND_LINE_ARGUMENT ; do
	case "${COMMAND_LINE_ARGUMENT}" in
	B)	NO_BACKUP=Bopt; ARGS="-B $ARGS" ;;
	C)	DONT_PRE_CLEAN=Copt; ARGS="-C $ARGS" ;;
	D)	DONT_SCRUB_DISTFILES=Dopt; ARGS="-D $ARGS" ;;
	F)	FETCH_ONLY=Fopt; ARGS="-F $ARGS" ;;
	G)	[ -z "$PM_FORCE_CONFIG" ] && {
			PM_NO_MAKE_CONFIG=Gopt; ARGS="-G $ARGS"; } ;;
	H)	HIDE_BUILD=Hopt; ARGS="-H $ARGS" ;;
	K)	DONT_POST_CLEAN=Kopt; ARGS="-K $ARGS" ;;
	L)	LIST_PLUS=Lopt ;;
	P)	packages_init first ;;
	R)	RESTART=Ropt ; ARGS="-R $ARGS" ;;
	a)	UPDATE_ALL=aopt ;;
	b)	BACKUP=bopt; ARGS="-b $ARGS" ;;
	d)	ALWAYS_SCRUB_DISTFILES=dopt; ARGS="-d $ARGS" ;;
	e)	EXPUNGE=$OPTARG ;;
	f)	export PM_FORCE=fopt ;;
	g)	MAKE_PACKAGE=gopt; ARGS="-g $ARGS" ;;
	h)	usage 0 ;;
	i)	INTERACTIVE_UPDATE=iopt; ARGS="-i $ARGS" ;;
	l)	LIST=lopt ;;
	m)	export PM_MAKE_ARGS=$OPTARG	# For 'make checksum'
		ARGS="-m $PM_MAKE_ARGS $ARGS" ;;
	n)	NO_ACTION=nopt; ARGS="-n $ARGS" ;;
	o)	REPLACE_ORIGIN=oopt ;;
	p)	fail 'The -p option has been deprecated' ;;
	r)	UPDATE_REQ_BYS=ropt
		if [ -d "$pdb/$OPTARG" ]; then
			glob_dirs=$OPTARG
		else
			find_glob_dirs $OPTARG
			case $? in
			1)	fail "$pdb/$OPTARG does not exist" ;;
			2)	fail 'The argument to -r must match only one port' ;;
			esac
		fi
		PM_RBP=${glob_dirs##*/} ; unset glob_dirs
		portdir=`origin_from_pdb $PM_RBP` ;;
	s)	CLEAN_STALE=sopt ;;
	t)	RECURSE_THOROUGH=topt; ARGS="-t $ARGS" ;;
	u)	fail 'The -u option has been deprecated' ;;
	v)	PM_VERBOSE=vopt; ARGS="-v $ARGS" ;;
	w)	SAVE_SHARED=wopt; ARGS="-w $ARGS" ;;
	x)	case "$OPTARG" in
		-*)	fail 'The -x option requires an argument' ;;
		esac
		PM_EXCL="${PM_EXCL}`globstrip ${OPTARG}` " ;;
	y)	PM_YES=yopt; ARGS="-y $ARGS" ;;
	*)	echo '' ; echo "===>>> Try ${0##*/} --help"; exit 1 ;;
	esac
done
shift $(( $OPTIND - 1 ))

[ -n "$UNATTENDED" ] && fail 'The -u option has been deprecated'

[ -n "$PM_EXCL" ] && export PM_EXCL

test_command_line () {
	local var envar

	for var in $my_environment; do
		case "$var" in
		${1}=*)	envar=$1 ;;
		${2}=*)	envar=$2 ;;
		esac
	done

	if [ -n "$envar" ]; then
		unset $envar
		return 0
	fi

	return 1
}

# Error checking for getopts
[ -n "$PM_FORCE" -a "$INTERACTIVE_UPDATE" ] &&
	fail "The -f and -i options are mutually exclusive"
if [ -n "$BACKUP" -a -n "$NO_BACKUP" ]; then
	test_command_line NO_BACKUP BACKUP ||
		fail "The -b and -B options are mutually exclusive"
fi
if [ -n "$ALWAYS_SCRUB_DISTFILES" -a -n "$DONT_SCRUB_DISTFILES" ]; then
	test_command_line ALWAYS_SCRUB_DISTFILES DONT_SCRUB_DISTFILES ||
		fail "The -d and -D options are mutually exclusive"
fi

[ -n "$PM_NO_MAKE_CONFIG" -a -n "$PM_FORCE_CONFIG" ] && unset PM_NO_MAKE_CONFIG

if [ -n "$LIST" -o -n "$LIST_PLUS" ]; then
	if [ -n "$FETCH_ONLY" -o -n "$RESTART" -o -n "$UPDATE_ALL" -o \
	    -n "$EXPUNGE" -o -n "$PM_FORCE" -o -n "$NO_ACTION" -o \
	    -n "$REPLACE_ORIGIN" -o -n "$UPDATE_REQ_BYS" -o -n "$CLEAN_STALE" ]; then
		fail 'The -[lL] options are not compatible with -FRaefnors'
	fi
	[ $# -gt 0 ] && fail 'The -[lL] options are not compatible with updates or installs'
fi

unset my_environment COMMAND_LINE_ARGUMENT
unset -f packages_init cross_idx test_command_line

#=============== End Command Line Option Processing ===============

# Update based on options chosen above
if [ "$$" -eq "$PM_PARENT_PID" ]; then
	if [ -n "$PM_PACKAGES" -o -n "$PM_PACKAGES_BUILD" ]; then
		[ `/sbin/sysctl -n kern.osreldate 2>/dev/null` -lt 600400 ] &&
			fail Package installation support requires FreeBSD 6.4 or newer
	fi

	if [ -n "$PM_INDEX" ]; then
		if [ -z "$INDEXFILE" ]; then
			ver=`uname -r`
			INDEXFILE=INDEX-${ver%%\.*}
			unset ver
		fi

		[ -z "$INDEXDIR" -a -n "$PM_INDEX_ONLY" -a -z "$pd" ] && INDEXDIR="$TMPDIR"

		PM_INDEX="${INDEXDIR:-$pd}/${INDEXFILE}"

		if [ -z "$PM_NO_INDEX_FETCH" ]; then
			: ${FETCHINDEX:='fetch -am -o'}
			: ${MASTER_SITE_INDEX:='http://www.FreeBSD.org/ports/'}

			index_fetch="$FETCHINDEX ${PM_INDEX}.bz2 ${MASTER_SITE_INDEX}${INDEXFILE}.bz2"
			do_index_fetch=yes_index_fetch

			index_time=`stat -f '%Um' ${PM_INDEX}.bz2 2>/dev/null`

			[ -n "$index_time" ] && {
				$index_fetch 2>/dev/null && do_index_fetch=no_index_fetch; }

			if [ "$do_index_fetch" = yes_index_fetch ]; then
				pm_sv 'Fetching new INDEX file'
				$PM_SU_CMD $index_fetch || fail Could not perform $index_fetch
			fi

			if [ ${index_time:-0} -ne `stat -f '%Um' ${PM_INDEX}.bz2 2>/dev/null` ]; then
				temp_index=`pm_mktemp index`
				bunzip2 < ${PM_INDEX}.bz2 > $temp_index
				pm_sv 'Installing new INDEX file'
				pm_install_s $temp_index $PM_INDEX
				unlink $temp_index
				unset temp_index
			fi
			unset index_fetch do_index_fetch index_time
		else
			[ -r "$PM_INDEX" ] ||
				fail "The --no-index-fetch option was used, but $PM_INDEX does not exist"
		fi

		PM_INDEX_PORTS=`pkg_version -Ivl\< $PM_INDEX | cut -f1 -d\<`
		export PM_INDEX_PORTS

		if [ -z "$pd" -o "$pd" != /usr/ports ]; then
			PM_IPD=`head -1 $PM_INDEX | cut -f 2 -d\|`
			PM_IPD=${PM_IPD%/*}
			PM_IPD=${PM_IPD%/*}

			[ -n "$PM_INDEX_ONLY" ] && pd=$PM_IPD
		else
			PM_IPD=$pd
		fi
		export PM_IPD
	fi

	if [ -n "$pd" ]; then
		pm_cd_pd && PM_WRKDIRPREFIX=`pm_make_b -V WRKDIRPREFIX` && pm_cd -
		export pd
	else
		if [ -n "$EXPUNGE" -o -n "$CLEAN_STALE" ]; then
			if [ -z "$DONT_SCRUB_DISTFILES" ]; then
				pm_v "===>>> There is no ports tree, so using -D option"
				unset ALWAYS_SCRUB_DISTFILES
				DONT_SCRUB_DISTFILES=Dopt_es; ARGS="-D $ARGS"
			fi
		elif [ -z "$LIST" -a -z "$LIST_PLUS" -a -z "$LIST_ORIGINS" -a -z "$CHECK_DEPENDS" ]; then
			fail 'The value of PORTSDIR cannot be empty'
		fi
	fi

	[ -z "$DISTDIR" -a "$PM_PACKAGES" != only -a -z "$CHECK_DEPENDS" -a \
	    -z "$CHECK_PORT_DBDIR" -a -z "$LIST_ORIGINS" ] &&
		DISTDIR=`pm_make_b -f/usr/share/mk/bsd.port.mk -V DISTDIR 2>/dev/null`

	[ -n "$DISTDIR" ] && { DISTDIR="${DISTDIR%/}/"; export DISTDIR; }

	if [ -n "$PM_PACKAGES_BUILD" -o -n "$PM_DEL_BUILD_ONLY" ]; then
		PM_BUILD_ONLY_LIST=pm_bol
		export PM_BUILD_ONLY_LIST
	fi
fi

#=============== Begin functions relevant to --features and main ===============

iport_from_origin () {
	local sn dir

	sn=${1#*/} ; sn=${sn%-*} ; sn=${sn%%[0-9]*}

	if ! dir=`grep -l "@comment ORIGIN:${1}$" $pdb/${sn}*/+CONTENTS 2>/dev/null`; then
		if ! dir=`grep -l "@comment ORIGIN:${1}$" $pdb/*/+CONTENTS 2>/dev/null`; then
			dir=`pkg_info -q -O $1` || return 1
		fi
	fi

	# It should not happen that more than one port meets this
	# requirement, but it can if the pkg data is corrupted.
	dir="${dir%%/+CONTENTS*}"
	echo ${dir#$pdb/}
}

check_regular_file () {
	[ ! -L "$1" -a -f "$1" ] || fail "ERROR: $1 is not a regular file!"
}

strip_to_iport () {
	local in

	while read in; do
		in="${in%/+CONTENTS}"
		in="${in##*/}"
		echo $in
	done
}

check_dependency_files () {
	# Global: grep_deps
	local origin iport ro_opd

	origin=$1 ; iport=$2

	# egrep hates + in file names
	case "$origin" in *+*) origin=`echo $origin | sed 's#\+#\\\\+#g'` ;; esac
	case "$ro_opd" in
	'')	ro_opd=a/a ;;
	*+*)	ro_opd=`echo $ro_opd | sed 's#\+#\\\\+#g'` ;; esac

	# Always rely on the grep'ed dependencies instead of +REQUIRED_BY
	grep_deps=`pm_mktemp grep-deps-${iport}`
	egrep -l "DEPORIGIN:($origin|$ro_opd)$" $pdb/*/+CONTENTS |
	    strip_to_iport | sort -u > $grep_deps

	if [ ! -s "$grep_deps" ]; then
		if [ -s "$pdb/$iport/+REQUIRED_BY" ]; then
			# No actual dependencies exist, so this file is stale
			# Zero it out so that -s mode can find it
			if [ -n "$PM_VERBOSE" -o -n "$CHECK_DEPENDS" ]; then
				echo "	===>>> No installed ports depend on $iport"
				echo "	===>>> Emptying +REQUIRED_BY file.  Try ${0##*/} -s"
			fi

			check_regular_file $pdb/$iport/+REQUIRED_BY
			$PM_SU_CMD truncate -s0 $pdb/$iport/+REQUIRED_BY
		fi
	fi
	return 0
}

# Takes a default value and message as input
# Return values:
# 0 - Answer is "Yes"
# 1 - Answer is "No"
#
get_answer () {
	local default answer

	default=$1 ; shift

	while : ; do
		if [ -z "$PM_YES" -a -z "$NO_ACTION" ]; then
			echo -n "	===>>> ${*}? y/n [${default}] "
			read answer
			echo ''
		else
			if [ -n "$PM_YES" ]; then
				answer=y
			elif [ -n "$NO_ACTION" ]; then
				answer=n
			fi
		fi

		case "$answer" in
		[yY])	return 0 ;;
		[nN])	return 1 ;;
		'')	[ "$default" = y ] && return 0 || return 1 ;;
		*)	echo "	===>>> $answer is not a valid response" ; echo '' ;;
		esac
	done
}

update_contents () {
	local IFS delete contents origin n_port old_origin iport new_cont
	local o_seen line d_missing d_origin d_iport prev_line answer

# To prevent words in a line being treated individually
IFS='
'
	[ "$1" = 'delete' ] && { delete=delete ; shift; }

	contents=$1 ; origin=$2 ; n_port=$3 ; old_origin=$4
	iport=${contents#$pdb/} ; iport=${iport%/+CONTENTS}
	new_cont=`pm_mktemp contents-${iport}`

	if [ -z "$delete" ]; then o_seen=':'; else o_seen=":${origin}:"; fi

	for line in `cat $contents`; do
		if [ -n "$d_missing" ]; then
			unset d_missing
			d_origin=${line#*DEPORIGIN:}

			case "$o_seen" in *:${d_origin}:*)
				unset prev_line line ; continue ;; esac
			o_seen="${o_seen}${d_origin}:"

			if [ "$d_origin" = "$old_origin" ]; then
				d_iport=$n_port
				d_origin=$origin
			else
				d_iport=`iport_from_origin $d_origin`
			fi

			if [ -n "$d_iport" ]; then
				[ -n "$PM_VERBOSE" -o -n "$CHECK_DEPENDS" ] &&
					echo "	===>>> Updating @pkgdep for $d_origin"
			else
				echo "	===>>> $d_origin is listed as a dependency"
				echo "	===>>> but there is no installed version"
				echo ''
				if [ -n "$CHECK_DEPENDS" ]; then
					get_answer n Delete this dependency data
					case "$?" in 0) unset prev_line line ; continue ;; esac
				else
					echo "	===>>> Try ${0##*/} --check-depends"
					echo ''
				fi
			fi

			# Could be fixed or not, but if we get here write it
			# so we can warn the user again later if we need to.
			echo "@pkgdep $d_iport" >> $new_cont
			echo "@comment DEPORIGIN:$d_origin" >> $new_cont
			unset prev_line
			continue
		fi
		case "$line" in
		"@comment DEPORIGIN:$origin"|"@comment DEPORIGIN:$old_origin")
			d_origin=${line#*DEPORIGIN:}
			unset prev_line line

			case "$o_seen" in *:${d_origin}:*) continue ;; esac
			o_seen="${o_seen}${d_origin}:"

			echo "@pkgdep $n_port" >> $new_cont
			echo "@comment DEPORIGIN:$origin" >> $new_cont ;;
		'@comment DEPORIGIN:'*)
			d_origin=${line#*DEPORIGIN:}
			case "$o_seen" in *:${d_origin}:*)
				unset prev_line line ; continue ;; esac
			o_seen="${o_seen}${d_origin}:" ;;
		'@pkgdep '|@pkgdep) d_missing=d_missing ;;
		@pkgdep*)	d_iport="${line#@pkgdep }"
				[ -d "$pdb/$d_iport" ] || d_missing=dm2 ;;
		esac
		[ -n "$prev_line" ] && echo $prev_line >> $new_cont
		prev_line=$line
	done
	[ -n "$prev_line" ] && echo $prev_line >> $new_cont

	cmp -s $contents $new_cont && { pm_unlink $new_cont ; return; }

	check_regular_file $contents
	[ -n "$PM_VERBOSE" -o -n "$CHECK_DEPENDS" ] &&
		echo "	===>>> Installing the new +CONTENTS file"
	pm_install_s $new_cont $contents
	pm_unlink $new_cont
}

find_moved_port () {
	# Global: moved_npd
	local sf iport IFS l reason

	sf=$1	# Search for
	iport=$2

	# To avoid having each word of the reason treated separately
	IFS='
'
	for l in `grep "^$sf|" $pd/MOVED`; do
		case "$l" in
		${sf}\|\|*) [ -n "$iport" ] || iport=`iport_from_origin $sf`
			if [ -e "$pdb/$iport/+IGNOREME" ]; then
				if [ -n "$PM_VERBOSE" ]; then
					echo ''
					echo "	===>>> The $sf port has been deleted"
					echo "	===>>> Reason: ${l##*|}"
					echo "	===>>> Skipping it due to +IGNOREME file"
					echo ''
				fi
				return 0
			else
				reason=${l##*|}
				[ "$3" != 'nonfatal' ] &&
					fail "The $sf port has been deleted: $reason"
			fi ;;
		${sf}\|*) moved_npd=${l#*\|}	# New port directory
			moved_npd=${moved_npd%%\|*}
			echo ''
			echo "	===>>> The $sf port moved to $moved_npd"
			echo "	===>>> Reason: ${l##*|}"
			echo ''
			find_moved_port $moved_npd ;;
		esac
	done

	if [ -z "$moved_npd" ]; then
		if [ -z "$reason" ]; then
			echo ''
			echo "	===>>> No $pd/$1 exists, and no information"
			echo "	===>>> about $1 can be found in $pd/MOVED"
		else	# Only reached in LIST_PLUS
			echo "	===>>> The $sf port has been deleted: $reason"
		fi
		echo ''

		[ -n "$iport" ] || iport=`iport_from_origin $sf`
		[ -e "$pdb/$iport/+IGNOREME" ] || return 1
	fi
	return 0
}

read_distinfos () {
	local pkg iport origin distinfo disc1 f disc2

	echo '############' > $DI_FILES		# Make the file > 0 bytes
	echo "===>>> Gathering distinfo list for installed ports"
	echo ''
	for pkg in ${pdb}/*; do
		[ -d $pkg ] || continue
		iport=${pkg#$pdb/}

		origin=`origin_from_pdb $iport` || continue

		if [ ! -d "$pd/$origin" ]; then
			find_moved_port $origin $iport nonfatal >/dev/null
			[ -n "$moved_npd" ] || continue
			origin=$moved_npd
		fi

		origin="${pd}/${origin}"

		if [ -s "${origin}/distinfo" ]; then
			distinfo="${origin}/distinfo"
		else
			pm_cd $origin || continue
			distinfo=`pm_make -V DISTINFO_FILE`
			[ -n "$distinfo" ] || fail "No DISTINFO_FILE in $origin"
		fi

		if [ -s "$distinfo" ]; then
			grep '^SHA256 ' $distinfo | while read disc1 f disc2; do
				f=${f#(} ; f=${f%)}
				echo $f >> $DI_FILES
			done
		fi
	done

	# Tell safe_exit that we are done
	[ -e "${DI_FILES}-e" ] && unlink ${DI_FILES}-e
	sed -i -e 1s/############/%%%%%%%%%%%%/ $DI_FILES
	[ -e "${DI_FILES}-e" ] && unlink ${DI_FILES}-e
}

read_distinfos_all () {
	local origin distinfo disc1 f disc2

	echo '############' > $DI_FILES		# Make the file > 0 bytes
	echo "===>>> Gathering distinfo list for all ports"
	echo '       (This will take several minutes)'
	echo ''

	for origin in ${pd}/*/*; do
		case "${origin#$pd/}" in
		Mk/*|T*|distfiles/*|packages/*|*/[Mm]akefile*|CVS/*|*/CVS) continue ;; esac

		[ -d "$origin" ] || continue

		if [ -s "${origin}/distinfo" ]; then
			distinfo="${origin}/distinfo"
		else
			pm_cd $origin || continue
			distinfo=`pm_make -V DISTINFO_FILE`
			[ -n "$distinfo" ] ||
				{ echo ''; echo "===>>> No DISTINFO_FILE in $origin"; echo ''; }
		fi

		if [ -s "$distinfo" ]; then
			grep '^SHA256 ' $distinfo | while read disc1 f disc2; do
				f=${f#(} ; f=${f%)}
				echo $f >> $DI_FILES
			done
		fi
	done

	# Tell safe_exit that we are done
	[ -e "${DI_FILES}-e" ] && unlink ${DI_FILES}-e
	sed -i -e 1s/############/%%%%%%%%%%%%/ $DI_FILES
	[ -e "${DI_FILES}-e" ] && unlink ${DI_FILES}-e
}

ports_by_category () {
	local pkg
	pm_v "===>>> Sorting ports by category"

	for pkg in $pdb/*; do
		if [ -s "$pkg/+REQUIRED_BY" ]; then
			if grep -ql '^@pkgdep ' $pkg/+CONTENTS 2>/dev/null; then
				branches="$branches ${pkg#$pdb/}"
			else
				trunks="$trunks ${pkg#$pdb/}"
			fi
		else
			if grep -ql '^@pkgdep ' $pkg/+CONTENTS 2>/dev/null; then
				leaves="$leaves ${pkg#$pdb/}"
			else
				[ -d "$pkg" ] || continue
				roots="$roots ${pkg#$pdb/}"
			fi
		fi
	done
}

delete_empty_dist_subdirs () {
	# Get back to somewhere safe so we do not
	# delete our CWD out from under ourselves
	pm_cd $DISTDIR || fail "Cannot cd into $DISTDIR"
	find -d $DISTDIR -type d \( -empty -and ! -path \*\.zfs/\* \) -delete
}

init_packages_var () {
	# Global: PACKAGES

	[ -n "$PACKAGES" ] && return

	PACKAGES=`pm_make -f/usr/share/mk/bsd.port.mk -V PACKAGES 2>/dev/null`
	if [ -z "$PACKAGES" ]; then
		if [ -d "${pd}/packages" -a -w "${pd}/packages" ]; then
			PACKAGES="${pd}/packages"
		else
			if [ -d "${pd}/" -a -w "${pd}/" ]; then
				PACKAGES="${pd}/packages"
			else
				fail 'The value of PACKAGES cannot be empty and the directory must be writable'
			fi
		fi
	fi
	export PACKAGES
}

parse_index () {
	local line

	line=`grep -m1 "|${PM_IPD}/${1}|" $PM_INDEX` || return 1

	case "$2" in
	name)		echo ${line%%|*} ;;
	localbase)	echo $line | cut -f 3 -d\| ;;
	comment)	echo $line | cut -f 4 -d\| ;;
	descr)		echo $line | cut -f 5 -d\| ;;
	maintainer)	echo $line | cut -f 6 -d\| ;;
	category)	echo $line | cut -f 7 -d\| ;;
	b-deps)		echo $line | cut -f 8 -d\| ;;
	r-deps)		echo $line | cut -f 9 -d\| ;;
	www)		echo $line | cut -f 10 -d\| ;;
	esac
}

#=============== End functions relevant to --features and main ===============
#=============== Begin code relevant only to --features ===============

if [ -n "$CLEAN_DISTFILES" ]; then
	[ -n "$DISTDIR" ] || fail 'There is no DISTDIR to clean'

	# Set the file name here since we are usually called in a subshell
	DI_FILES=`pm_mktemp DI-FILES`

	if [ -z "$RECURSE_THOROUGH" ]; then
		read_distinfos
	else
		read_distinfos_all
	fi

	echo "===>>> Checking for stale distfiles" ; echo ''
	for df in `find $DISTDIR -type f | sort`; do
		f=${df#$DISTDIR}
		if ! grep -ql $f $DI_FILES; then
			get_answer n Delete stale file: ${f}
			case "$?" in
			0)	echo "       Deleting $f" ; echo ''
				pm_unlink $df ;;
			*)	continue ;;
			esac
		fi
	done

	delete_empty_dist_subdirs
	safe_exit
fi

if [ -n "$CLEAN_PACKAGES" ]; then
	init_packages_var

	echo "===>>> Checking for stale packages"
	for package in `find $PACKAGES -type f | sort`; do
		pkg_dir=${package##*/} ; pkg_dir=${pkg_dir%\.tbz} ; echo ''

		origin=`tar -O -zxvf $package '+CONTENTS' 2>/dev/null | grep '@comment ORIGIN:'` ||
			fail Empty origin in $package
		origin=${origin#@comment ORIGIN:}

		if [ -z "$PM_INDEX" ]; then
			if [ -d "$pd/$origin" ]; then
				pm_cd $pd/$origin && port_ver=`pm_make -V PKGNAME`
				[ -n "$port_ver" ] || fail "Is $pd/$origin/Makefile missing?"
			else
				echo "===>>> The origin for ${package##*/} ($origin) is missing"
			fi
		else
			if ! port_ver=`parse_index $origin name`; then
				echo "===>>> Cannot determine latest version of ${package##*/} from $PM_INDEX"
			fi
		fi

		if [ -n "$port_ver" ]; then
			if [ "${port_ver}.tbz" = "${package##*/}" ]; then
				echo "===>>> ${package##*/} is up to date"
				if [ -z "$PM_YES" ]; then
					if [ ! -d "${pdb}/${pkg_dir}" ]; then
						echo "	===>>> $pkg_dir is not installed"
						get_answer y Delete stale package: ${package##*/}
						case "$?" in
						0)	echo "	===>>> Deleting $package"
							pm_unlink_s $package ;;
						esac
					fi
				fi
				unset port_ver
				continue
			fi

			echo "===>>> Package version: $pkg_dir"
			echo "       Latest version:  $port_ver"

			unset port_ver

			if [ -d "${pdb}/${pkg_dir}" ]; then
				echo "	===>>> ${package##*/} matches the installed version"
			else
				echo "	===>>> ${package##*/} is not installed"
			fi
		fi

		echo "	===>>> Path: ${package}"

		get_answer n Delete stale package: ${package##*/}
		case "$?" in
		0)	echo "	===>>> Deleting $package"
			pm_unlink_s $package ;;
		esac
	done
	echo '' ; echo ''

	echo "===>>> Deleting stale symlinks"
	pm_cd $PACKAGES || fail "Cannot cd to $PACKAGES"
	for link in `find . -type l | sort` ; do
		if [ ! -e "$link" ]; then
			echo "	===>>> ${link#./}"
			$PM_SU_CMD /bin/unlink $link
		fi
	done
	echo '' ; echo ''

	empty_dirs=`find . -type d -empty -print | sort`
	case "$empty_dirs" in
	\.|'')	echo "===>>> No empty directories in $PACKAGES" ;;
	*)	echo "===>>> Deleting empty directories"
		for dir in $empty_dirs; do
			echo "	===>>> ${dir#\.\/}"
		done
		pm_find_s . -type d -empty -delete ;;
	esac
	echo ''

	safe_exit
fi	# [ -n "$CLEAN_PACKAGES" ]

if [ -n "$CHECK_DEPENDS" ]; then
	d_orig_ok=':'
IFS='
'
	for pkg in $pdb/*; do
		[ -d "$pkg" ] || continue

		iport=${pkg#$pdb/}

		echo "===>>> Checking $iport"

		if [ ! -r "$pkg/+CONTENTS" ]; then
			echo "	===>>> Warning: No +CONTENTS file!"
			continue
		fi

		origin=`origin_from_pdb $iport` || continue

		if [ -n "$pd" ] && [ ! -d "$pd/$origin" ]; then
			echo "	===>>> $pd/$origin does not exist"
			echo "	===>>> This port should probably be updated"
			continue
		fi

		check_dependency_files $origin $iport
		if [ -s "$grep_deps" ]; then
			if [ -e "$pkg/+REQUIRED_BY" ]; then
				sort $pkg/+REQUIRED_BY | cmp -s $grep_deps - ||
					do_update=do_update
				check_regular_file $pkg/+REQUIRED_BY
			else
				do_update=do_update2
			fi
			if [ -n "$do_update" ]; then
				unset do_update
				echo "	===>>> Updating +REQUIRED_BY"
				pm_install_s $grep_deps $pkg/+REQUIRED_BY
			fi
		fi
		[ -n "$grep_deps" ] && { pm_unlink $grep_deps && unset grep_deps; }

		update_contents $pkg/+CONTENTS
	done
	exit 0
fi

if [ -n "$CHECK_PORT_DBDIR" ]; then
	[ -d "$port_dbdir" ] ||
		fail 'PORT_DBIR is empty, or the directory $port_dbdir does not exist'

	unique_list=':'

	echo "===>>> Building list of installed port names"; echo ''
	for pkg in $pdb/*; do
		[ -d $pkg ] || continue

		unset unique_name

		iport=${pkg#$pdb/}
		origin=`origin_from_pdb $iport` || continue

		if [ ! -d "$pd/$origin" ]; then
			find_moved_port $origin $iport nonfatal >/dev/null
			[ -n "$moved_npd" ] || continue
			origin=$moved_npd
		fi

		if ! pm_cd $pd/$origin; then
			echo "	===>>> $pd/$origin does not exist for $pkg"
			continue
		fi
		unique_name=`make -V UNIQUENAME`
		unique_list="${unique_list}${unique_name}:"
	done

	echo "===>>> Checking $port_dbdir"

	[ -n "$PM_VERBOSE" ] && { print='-print'; echo '';
		echo "===>>> Deleting empty directories (if any)"; }
	pm_find_s $port_dbdir -type d -empty $print -delete
	pm_v

	for dir in ${port_dbdir}/*; do
		dbdir=${dir#$port_dbdir/}

		[ -n "$PM_VERBOSE" ] && echo -n "===>>> Checking ${dbdir}: "
		case "$unique_list" in
		*:${dbdir}:*)	pm_v "Ok" ;;
		*)	pm_v
			echo "	===>>> $dbdir does not seem to be installed"
			get_answer n Delete ${dir}
			case "$?" in 0) pm_rm_s -rf $dir ;; esac
			echo '' ;;
		esac
	done
	exit 0
fi

if [ -n "$LIST_ORIGINS" ]; then
	ports_by_category

	for iport in $roots $leaves; do
		origin=`origin_from_pdb $iport` || continue
		echo $origin
	done

	exit 0
fi

#=============== End code relevant only to --features ===============
#=============== Begin functions for getopts features and main ===============

check_state () {
	# Global: state
	local state_set

	if egrep -ql '^(FORBIDDEN|DEPRECATED|BROKEN|IGNORE)' Makefile; then
		for state in FORBIDDEN DEPRECATED BROKEN IGNORE; do
			state_set=`pm_make -V $state`
			if [ -n "$state_set" ]; then
				echo "	===>>> This port is marked $state"
				printf "	===>>> $state_set\n"
				echo ''
				return 1
			fi
		done
	fi
	return 0
}

# Takes $iport and $origin as arguments
#
check_force_multi () {
	if [ -n "$PM_FORCE" ]; then
		check_restart_and_udf $1 || return 1
	elif [ -n "$URB_YES" ]; then
		case "$MASTER_RB_LIST" in
		*" $1 "*) check_restart_and_udf $1 || return 1 ;;
		esac
	elif [ -n "$PM_MULTI_PORTS" ]; then
		case "$PM_MULTI_PORTS" in
		*:${1}:*)	return 1 ;;
		*:${2}:*)	return 1 ;;
		esac
	fi
}

check_for_updates () {
	# Global: num_updates
	local nf iport origin port_ver do_update skip

	[ "$1" = 'list' ] && { nf=nonfatal; shift; }

	iport=$1 ; origin=${2:-`origin_from_pdb $iport`} || return 0

	if [ -n "$PM_INDEX" ]; then
		case "$PM_INDEX_PORTS" in
		*${iport}*)	port_ver=`parse_index $origin name` ||
					fail "No entry for $origin in $PM_INDEX"
				do_update=upd_idx ;;
		esac

		[ -z "$do_update" -a -z "$LIST_PLUS" ] && {
			check_force_multi $iport $origin || do_update=upd_fm_idx; }

		[ -n "$PM_INDEX_FIRST" ] || skip=index_skip
	fi

	if [ -d "$pd/$origin" -a -z "$do_update" -a -z "$skip" ]; then
		if ! pm_cd $pd/$origin; then
			if [ -e "$pdb/$iport/+IGNOREME" ]; then
				echo "	===>>> Warning: Unable to cd to $pd/$origin"
				echo "	===>>> Continuing due to $pdb/$iport/+IGNOREME"
				echo ''
				CUR_DEPS="${CUR_DEPS}${iport}:${origin}:"
				return 0
			else
				fail "Cannot cd to port directory: $pd/$origin"
			fi
		fi
		port_ver=`pm_make -V PKGNAME`
		[ -z "$port_ver" ] && fail "Is $pd/$origin/Makefile missing?"
	elif [ -z "$do_update" -a -z "$skip" ]; then
		find_moved_port $origin $iport $nf

		# If the port has moved and no +IGNOREME, we have to update it
		if [ -n "$moved_npd" ]; then
			if [ ! -e "$pdb/$iport/+IGNOREME" ]; then
				do_update=do_update_moved
			else
				echo "	===>>> Continuing due to $pdb/$iport/+IGNOREME"
				echo ''
				CUR_DEPS="${CUR_DEPS}${iport}:${origin}:"
				return 0
			fi
		fi
	fi

	if [ -z "$do_update" -a -n "$port_ver" ]; then
		if [ "$iport" = "$port_ver" ]; then
			if [ -n "$LIST_PLUS" ]; then
				check_state
				return 0
			elif [ -n "$LIST" ]; then
				return 0
			else
				check_force_multi $iport $origin || do_update=upd_fm_eq
				unset port_ver
			fi
		else
			case `pkg_version -t $iport $port_ver` in
			\<)	do_update=upd_lt ;;
			=)	;;	# Can be reached if same version with different options
			\>)	if [ -n "$PM_VERBOSE" ]; then
					echo "	===>>> Port version $port_ver does not"
					echo "	===>>> seem newer than installed $iport"
				fi ;;
			*)	fail "pkg_version -t $iport $port_ver gave an unexpected result"
			esac

			[ -z "$do_update" ] && {
				check_force_multi $iport $origin || do_update=upd_fm_ne; }
		fi
	fi

	if [ -z "$do_update" ]; then
		[ -z "$LIST_PLUS" ] && CUR_DEPS="${CUR_DEPS}${iport}:${origin}:"
		return 0
	fi

	if [ -n "$LIST_PLUS" ]; then
		if [ -z "$moved_npd" ]; then
			echo "	===>>> New version available: $port_ver"
			[ -e "$pdb/$iport/+IGNOREME" ] &&
				echo "	===>>> +IGNOREME file is present for $1"
			pm_cd_pd $origin && check_state
			num_updates=$(( $num_updates + 1 ))
		else
			unset moved_npd
		fi
		return 0
	elif [ "$PM_RBP" = "$iport" ]; then
		PM_RBP_NEEDS_UPGRADE=pm_rbp_needs_upgrade
		return 0
	fi

	# No need for check_exclude here because it is already
	# run in the places that call check_for_updates().
	check_interactive $iport $port_ver || return 0
	update_port $iport $port_ver || return 1
	return 0
}

init_packages () {
	# Global: pbu

	[ -n "$FETCH_ONLY" ] && return

	init_packages_var

	[ -n "$NO_BACKUP" ] && return

	pbu=$PACKAGES/portmaster-backup

	if [ ! -d "$pbu" ]; then
		pm_sv Creating $pbu
		pm_mkdir_s $pbu
	fi
	export pbu
}

pm_pkg_create () {
	local pkgdir backup

	init_packages

	if [ "$1" = "$PACKAGES" ]; then
		for pkgdir in All Latest ${portdir%/*}; do
			pm_mkdir_s ${PACKAGES}/${pkgdir} ||
				fail "Cannot mkdir -p ${PACKAGES}/${pkgdir}"
		done
		pkgdir=${PACKAGES}/All
		echo "===>>> Creating a package for new version $2"
	else
		pkgdir=$1 ; echo ''
		echo "===>>> Creating a backup package for old version $2"
		backup=backup
	fi

	pm_cd $pkgdir || fail "Cannot cd into $pkgdir to create a package"
	if $PM_SU_CMD pkg_create -b $2; then
		if [ "$1" = "$pbu" ]; then
			if [ -n "$BACKUP" ]; then
				echo "	===>>> Package saved to $1" ; echo ''
			else
				local pkg ; pkg=`echo $2.*`
				NB_DELETE="${NB_DELETE}${pkg} "
			fi
		elif [ "$1" = "$PACKAGES" ]; then
			local pkg ; pkg=`echo $2.*`

			if [ -z "$PM_INDEX_ONLY" ]; then
				local latest_link

				pm_cd_pd $portdir
				latest_link=`pm_make -V LATEST_LINK`
				cd ${1}/Latest
				$PM_SU_CMD ln -sf ../All/$pkg ${latest_link}.tbz
			fi

			cd ${1}/${portdir%/*}
			$PM_SU_CMD ln -sf ../All/$pkg $pkg
			echo "  ===>>> Package saved to ${1}/All" ; echo ''
		fi
	else
		echo ''
		echo "===>>> Package creation failed for ${2}!"
		echo ''

		[ -n "$backup" -a -n "$PM_IGNORE_FAILED_BACKUP_PACKAGE" ] && return

		echo "===>>> Ignore this error  [i]"
		echo "===>>> Abort              [a]"
		echo ''
		echo -n "===>>> How would you like to proceed? [i] "
		local answer ; read answer
		case "$answer" in
		[aA])	fail "Package creation failed for $2" ;;
		esac
	fi
}

find_dl_distfiles () {
	# Global: dist_list dist_list_files
	local file

	# We need to define these for use in the deletion/update process.
	if pm_cd $pd/$1; then
		dist_list=`pm_make_b -V OPTIONSFILE`
		dist_list="${dist_list%options}distfiles"

		[ -s "$dist_list" ] || { unset dist_list ; return 0; }
		[ -n "$DONT_SCRUB_DISTFILES" ] && return 0

		# The grep is needed to allow for comments, etc.
		for file in `grep ^DISTFILE $dist_list`; do
			file=${file#DISTFILE:} ; file=${file%%:*}
			dist_list_files="${dist_list_files}${file#*/} "
		done
	else
		# The port might have moved, etc.; so take a stab at it,
		# but do not take a chance with a possibly wrong answer
		dist_list="$port_dbdir/${1##*/}/distfiles"

		[ -s "$dist_list" ] || { unset dist_list ; return 0; }
		[ -n "$DONT_SCRUB_DISTFILES" ] && return 0

		# Do not strip the subdir, we will use it in delete_all
		for file in `grep ^DISTFILE $dist_list`; do
			file=${file#DISTFILE:} ; file=${file%%:*}
			dist_list_files="${dist_list_files}${file} "
		done
	fi
}

delete_dist_list () {
	[ -n "$dist_list" ] || return 0

	local dir

	pm_sv Deleting $dist_list
	pm_unlink_s $dist_list

	dir=`find ${dist_list%/distfiles} -type d -empty 2>/dev/null`
	if [ -d "$dir" ]; then
		pm_sv Deleting the $dir directory
		pm_rmdir_s $dir
	fi
}

find_and_delete_distfiles () {
	# Global: port_subdir DISTDIR distfiles distfiles_checked delete_all
	local ps pattern file answer

	ps=${port_subdir#$DISTDIR}

	pattern=${1%[_-]*}
	for file in ${pattern}*; do
		# This generally means the pattern did not match
		case "$file" in
		*\*)	[ "$pattern" = "${pattern%[_-]*}" ] && return 0
			# This will happen for files like foo-bar_baz-1.23
			find_and_delete_distfiles $pattern ;;
		esac

		case "$distfiles_checked" in *:${file}:*) continue ;; esac
		[ -f "$file" ] || continue

		case "$distfiles" in
		*" ${file} "*)
			distfiles_checked="${distfiles_checked}${file}:"
			pm_v "===>>> Keeping current distfile: $file"
			continue ;;	# Do not delete current version
		*)	if [ -s "$DI_FILES" ]; then
				grep -ql ${ps}$file $DI_FILES && continue
			fi

			if [ -n "$ALWAYS_SCRUB_DISTFILES" -o -n "$delete_all" ]; then
				echo "===>>> Deleting stale distfile: $file"
				pm_unlink $file
				continue
			fi

			echo -n "===>>> Delete $file? y/n [n] "
			read answer
			case "$answer" in
			[yY])	pm_unlink $file ;;
			*) distfiles_checked="${distfiles_checked}${file}:" ;;
			esac ;;
		esac
	done
}

set_distfiles_and_subdir () {
	# Global: dist_list_files distfiles port_subdir DISTDIR

	[ -z "$dist_list_files" ] && find_dl_distfiles $1

	if [ -d "$pd/$1" ]; then
		pm_cd_pd $1
	else
		return 1
	fi

	if [ -z "$distfiles" ]; then
		distfiles=`pm_make -V ALLFILES | sed -e 's# *$##g'`
		[ -n "$distfile" ] && distfiles=" ${distfiles} "
	fi
	# Ports may have no distfiles
	[ -z "$dist_list_files" -a -z "$distfiles" ] && return 2

	if [ -z "$port_subdir" ]; then
		port_subdir=`pm_make -V DIST_SUBDIR`
		if [ -n "$port_subdir" ]; then
			port_subdir="${DISTDIR}${port_subdir}/"
		else
			port_subdir=$DISTDIR
		fi
	fi
	if [ -d "$port_subdir" ]; then
		pm_cd $port_subdir || fail "cd to $port_subdir failed!"
	else
		echo ''
		echo "===>>> $port_subdir does not exist, therefore we"
		echo '       will assume that all relevant distfiles are gone.'
		echo ''
		echo "       Try ${0##*/} [-y] --clean-distfiles for a full cleanup"
		echo ''
		return 3
	fi
	return 0
}

delete_stale_distfiles () {
	# Global: distfiles port_subdir distfiles_checked delete_all
	local file answer

	set_distfiles_and_subdir $1 || return 0
	distfiles_checked=':'

	# If these two match, it means that the distfiles in the +CONTENTS
	# file are the current set, so do not delete them.
	if [ ! " $dist_list_files" = "$distfiles" ]; then
		for file in $dist_list_files; do
			[ -f "$file" ] || continue

			case "$distfiles" in
			*" ${file} "*)
				distfiles_checked="${distfiles_checked}${file}:"
				pm_v "===>>> Keeping current distfile: $file"
				continue ;;	# Do not delete current version
			esac

			if [ -n "$ALWAYS_SCRUB_DISTFILES" -o -n "$delete_all" ]; then
				echo "===>>> Deleting stale distfile: $file"
				pm_unlink $file
				continue
			fi

			echo -n "===>>> Delete $file? y/n [n] "
			read answer
			case "$answer" in
			[yY])	pm_unlink $file ;;
			*) distfiles_checked="${distfiles_checked}${file}:" ;;
			esac
		done
	fi

	# Eventually we will hide this behind an "aggressive distfile purge"
	# flag, but until the DISTFILE stuff is well populated in PORT_DBDIR,
	# keep doing it both ways.
	for file in $distfiles $dist_list_files; do
		find_and_delete_distfiles $file
	done

	pm_v "===>>> Distfile cleaning complete" ; pm_v
}

delete_all_distfiles () {
	# Global: delete_all DISTDIR
	local origin rc delete_current

	# In case we are called more than once
	unset delete_all dist_list dist_list_files
	origin=$1

	set_distfiles_and_subdir $origin ; rc=$?
	case "$rc" in
	1)	echo ''
		echo "===>>> No $pd/$origin exists to find the distfile list"
		echo "       Try ${0##*/} [-y] --clean-distfiles for a full cleanup"
		echo ''
		if [ -n "$dist_list_files" ]; then
			local answer f

			if [ -z "$ALWAYS_SCRUB_DISTFILES" ]; then
				echo "===>>> However, the list of files in $dist_list"
				echo -n "       should be current.  Delete the files on this list? y/n [n] "
				read answer
			else
				answer=y
			fi

			case "$answer" in
			[yY])	for f in $dist_list_files; do
					if [ -f "${DISTDIR}${f}" ]; then
						echo "       Deleting ${DISTDIR}${f}"
						pm_unlink ${DISTDIR}${f}
					fi
				done ;;
			esac
		fi
		return 0 ;;
	2)	echo "===>>> This port has no distfiles" ; return 0 ;;
	3)	return 0 ;;	# port_subdir does not exist
	esac

	if [ -n "$ALWAYS_SCRUB_DISTFILES" ]; then
		echo "===>>> Deleting all distfiles for $origin"
		delete_all=delete_all
	else
		echo "===>>> Delete old and new distfiles for $origin"
		echo -n "       without prompting? y/n [n] "
		local answer ; read answer
		case "$answer" in
		[yY])	delete_all=delete_all2 ;;
		*)	echo -n "===>>> Delete the current distfiles? y/n [n] "
			read answer
			case "$answer" in
			[yY])	delete_current=delete_current ;;
			esac ;;
		esac
	fi

	if [ -n "$delete_all" -o -n "$delete_current" ]; then
		# Doing this now means less work in delete_stale()
		[ -n "$distfiles" ] && eval rm -f $distfiles
	fi
	delete_stale_distfiles $origin
	delete_empty_dist_subdirs
}

#=============== End functions for getopts features and main ===============
#=============== Begin code relevant only to getopts features ===============

if [ -n "$LIST" -o -n "$LIST_PLUS" ]; then
	ports_by_category
	num_roots=0; num_trunks=0; num_branches=0; num_leaves=0; num_updates=0

	pm_v ; echo "===>>> Root ports (No dependencies, not depended on)"
	for iport in $roots; do
		echo "===>>> $iport"
		[ -n "$LIST_PLUS" ] && check_for_updates list $iport
		num_roots=$(( $num_roots + 1 ))
	done
	echo "===>>> $num_roots root ports"
	echo ''
	echo "===>>> Trunk ports (No dependencies, are depended on)"
	for iport in $trunks; do
		echo "===>>> $iport"
		[ -n "$LIST_PLUS" ] && check_for_updates list $iport
		num_trunks=$(( $num_trunks + 1 ))
	done
	echo "===>>> $num_trunks trunk ports"
	echo ''
	echo "===>>> Branch ports (Have dependencies, are depended on)"
	for iport in $branches; do
		echo "===>>> $iport"
		[ -n "$LIST_PLUS" ] && check_for_updates list $iport
		num_branches=$(( $num_branches + 1 ))
	done
	echo "===>>> $num_branches branch ports"
	echo ''
	echo "===>>> Leaf ports (Have dependencies, not depended on)"
	for iport in $leaves; do
		echo "===>>> $iport"
		[ -n "$LIST_PLUS" ] && check_for_updates list $iport
		num_leaves=$(( $num_leaves + 1 ))
	done
	echo "===>>> $num_leaves leaf ports"
	echo ''
	num_ports=$(( $num_roots + $num_trunks + $num_branches + $num_leaves ))
	echo "===>>> $num_ports total installed ports"

	if [ "$num_updates" -gt 1 ]; then
		echo "	===>>> $num_updates have new versions available"
	elif [ "$num_updates" -eq 1 ]; then
		echo "	===>>> 1 has a new version available"
	elif [ -n "$LIST_PLUS" ]; then
		echo "	===>>> There are no new versions available"
	fi

	exit 0
fi

if [ -n "$EXPUNGE" ]; then
	if [ ! -d "$pdb/$EXPUNGE" ]; then
		find_glob_dirs $EXPUNGE
		case $? in
		1)	fail "No such directory/port: $pdb/$EXPUNGE" ;;
		2)	echo "===>>> $EXPUNGE matched multiple ports"
			fail "The -e option works with only one port at a time" ;;
		0)	EXPUNGE=${glob_dirs#$pdb/}
			unset glob_dirs ;;
		esac
	fi

	origin=`origin_from_pdb $EXPUNGE`
	deplist=`grep -l DEPORIGIN:$origin$ $pdb/*/+CONTENTS`
	if [ -n "$deplist" ]; then
		echo "===>>> Warning: Ports with dependencies on ${EXPUNGE}:"
		for dep in $deplist; do
			dep=${dep%/+CON*} ; echo "	${dep##*/}"
		done
		echo ''
		get_answer n Delete this dependency data
		case "$?" in
		0)	for f in $deplist; do
				update_contents delete $f $origin
			done ;;
		*)	exit 1 ;;
		esac
	fi

	[ -n "$BACKUP" ] && { init_packages ; pm_pkg_create $pbu $EXPUNGE; }
	[ -z "$DONT_SCRUB_DISTFILES" ] && { delete_all_distfiles $origin; delete_dist_list; }

	echo "===>>> Running pkg_delete -f $EXPUNGE"
	pm_pkg_delete_s -f $EXPUNGE || fail 'pkg_delete failed'

	echo '' ; echo "===>>> Running ${0##*/} -s $ARGS"
	exec $0 -s $ARGS
	exit 0	# Should not be reached
fi

if [ -n "$CLEAN_STALE" ]; then
	[ -z "$no_del_list" ] && export no_del_list=':'

	for file in `find $pdb -type f -name \+REQUIRED_BY -empty` ; do
		iport="${file%/+REQUIRED_BY}" ; iport=${iport#$pdb/}

		case "$no_del_list" in *:${iport}:*) continue ;; esac

		origin=`origin_from_pdb $iport`
		deplist=`grep -l DEPORIGIN:$origin$ $pdb/*/+CONTENTS`
		if [ -n "$deplist" ]; then
			echo ''
			echo "===>>> Warning: Unrecorded dependencies on ${iport}:"
			for dep in $deplist; do
				dep=${dep%/+CON*} ; echo "	${dep##*/}"
			done
			echo ''
			echo "===>>> Try ${0##*/} --check-depends"
			echo ''
			continue
		fi

		pkg_info $iport

		get_answer n ${iport} is no longer depended on, delete
		case "$?" in
		0)	[ -n "$BACKUP" ] && { init_packages ; pm_pkg_create $pbu $iport; }
			[ -z "$DONT_SCRUB_DISTFILES" ] && { delete_all_distfiles $origin; delete_dist_list; }

			echo "===>>> Running pkg_delete -f $iport"
			pm_pkg_delete_s -f $iport || fail 'pkg_delete failed'

			exec $0 -s $ARGS ;;
		*)	get_answer y Delete this dependency data
			case "$?" in
			0)	pm_unlink_s $file ;;
			*)	no_del_list="${no_del_list}${iport}:" ;;
			esac ;;
		esac
	done
	exit 0
fi

#=============== End code relevant only to getopts features ===============

[ -z "$DISTDIR" -a "$PM_PACKAGES" != only -a -z "$DONT_SCRUB_DISTFILES" ] &&
	fail 'The value of DISTDIR cannot be empty'

#=============== Begin functions for main ===============

already_done () {
	[ -n "$PM_VERBOSE" ] || return 0
	echo "===>>> The update for $1 is already done"
}

check_restart_and_udf () {
	# RESTART will usually be empty, and we don't want
	# to go out to the disk if we don't have to.
	[ -z "$RESTART" ] && return 1

	if [ ! -e "$pdb/${1}/PM_UPGRADE_DONE_FLAG" ]; then
		return 1
	else
		already_done $1 ; echo ''
	fi
}

check_interactive () {
	[ -n "$INTERACTIVE_UPDATE" ] || return 0

	local update_to

	[ -n "$2" ] && update_to=" to $2"

	case "$INTERACTIVE_YES" in *:${1}:*) return 0 ;; esac
	case "$INTERACTIVE_NO" in *:${1}:*) return 1 ;; esac

	if [ -e "$pdb/$1/+IGNOREME" ]; then
		echo ''
		echo "===>>> +IGNOREME file is present for $1"
	fi

	echo '' ; echo -n "===>>> Update ${1}${update_to}? y/n [y] "
	local answer ; read answer
	case "$answer" in
	[yY]|'')	INTERACTIVE_YES="${INTERACTIVE_YES}${1}:" ;;
	*)		INTERACTIVE_NO="${INTERACTIVE_NO}${1}:" ; return 1 ;;
	esac
	return 0
}

check_exclude () {
	[ -n "$PM_EXCL" ] || return 0

	local pat

	for pat in $PM_EXCL; do
		case "$1" in
		*${pat}*)
			if [ -n "$PM_VERBOSE" ]; then
				echo "===>>> Skipping $1"
				echo "       because it matches the pattern: *${pat}*"
				echo ''
			fi
			return 1 ;;
		esac
	done

	return 0
}

check_fetch_only () {
	[ -n "$FETCH_ONLY" ] || return 0

	local sleep nf fetches

	echo ''
	sleep=5
	while `ls ${TMPDIR}/f-${PM_PARENT_PID}-fetchlog-* >/dev/null 2>&1`; do
		nf=`ps -ax | grep [f]etch | wc -l`
		nf=${nf##* }
		[ "$nf" -eq 0 ] && break	# Not often, but it happens
		fetches=fetches ; [ "$nf" -eq 1 ] && fetches=fetch
		echo "===>>> Waiting for ${nf##* } distfile $fetches to finish"
		sleep $sleep

		if [ $sleep -eq 10 ]; then
			sleep=5
		else
			sleep=$(( $sleep + 1 ))
		fi
	done
	echo "===>>> Distfile fetching is complete"
	FETCH_ONLY_DONE=fetch_only_done
	safe_exit
}

term_printf () {
	[ -n "$PM_NO_TERM_TITLE" ] && return
	case "$TERM" in cons*) return ;; esac

	printf "\033]0;${0##*/}: ${PM_PARENT_PORT}${1}\007"
}

update_pm_nu () {
	case "$PM_NEEDS_UPDATE" in *\ $1\ *) return ;; esac

	PM_NEEDS_UPDATE="${PM_NEEDS_UPDATE}${1} "
}

update_build_l () {
	local origin iport new_port

	case "$1" in
	*/*)	origin=$1
		update_pm_nu $origin
		[ -n "$PM_NO_CONFIRM" ] && return
		case "$build_l" in *\ $origin\\*) return ;; esac
		iport=`iport_from_origin $origin`
		if [ -z "$iport" ]; then
			build_l="${build_l}\tInstall $origin\n"
			return
		fi ;;
	*)	iport=$1
		origin=`origin_from_pdb $1`
		update_pm_nu $origin
		case "$build_l" in *\ $iport\ *|*\ $iport\\*) return ;; esac ;;
	esac

	[ -n "$PM_NO_CONFIRM" ] && return

	if [ -z "$PM_INDEX_ONLY" ]; then
		pm_cd $pd/$origin && new_port=`pm_make -V PKGNAME`
	else
		new_port=`parse_index $origin name` ||
			fail "No entry for $origin in $PM_INDEX"
	fi

	case `pkg_version -t $iport $new_port 2>/dev/null` in
	\<)	build_l="${build_l}\tUpgrade $iport to $new_port\n" ;;
	=)	build_l="${build_l}\tRe-install $iport\n" ;;
	\>)	build_l="${build_l}\tDowngrade $iport to $new_port\n" ;;
	*)	build_l="${build_l}\tUpgrade $iport\n" ;;
	esac
}

update_port () {
	local deps

	if [ -n "$2" ]; then
		echo "===>>> Launching child to update $1 to $2"
	else
		case "$1" in
		*/*)	echo "===>>> Launching child to install ${1#$pd/}" ;;
		*)	if [ -z "$FETCH_ONLY" ]; then
				echo "===>>> Launching child to reinstall $1"
			else
				echo "===>>> Launching child to check distfiles for $1"
			fi ;;
		esac
	fi

	dep_of_deps=$(( $dep_of_deps + 1 ))

	[ -n "$PM_FIRST_PASS" ] && num_of_deps=$(( $num_of_deps + 1 ))

	deps=" (${dep_of_deps}/${num_of_deps})"

	if [ -n "$PM_DEPTH" ]; then
		echo "	${PM_DEPTH}>> ${1#$pd/}"
		term_printf " ${PM_DEPTH#* }>> ${1#$pd/}${deps}"
	else
		[ -n "$UPDATE_ALL" ] && term_printf " >> ${1#$pd/}${deps}"
	fi

	[ -n "$doing_dep_check" -o \( -n "$UPDATE_ALL" -a -n "$PM_FIRST_PASS" \) ] &&
		unset NO_DEP_UPDATES

	if [ -z "$NO_ACTION" -o -n "$PM_FIRST_PASS" ]; then
		($0 $ARGS $1) || fail "Update for $1 failed"
		. $IPC_SAVE
	else
		pm_v "===>>> Build canceled due to -n flag"
	fi

	if [ -n "$UPDATE_ALL" ]; then
		term_printf " (${num_of_deps})"
		echo "===>>> Returning to update check of installed ports"
		echo ''
	elif [ -n "$UPDATE_REQ_BYS" ]; then
		return 0
	elif [ -n "$PM_FIRST_PASS" -a -z "$PM_PACKAGES" ]; then
		echo "===>>> Continuing initial dependency check for $portdir"
	else
		term_printf " ${PM_DEPTH#* }${deps}"
		echo "===>>> Returning to dependency check for $portdir"
	fi
	return 0
}

uniquify_list () {
	local item temp_list

	for item in "$@"; do
		case "$temp_list" in
		*" $item "*) ;;
		*)	temp_list=" $temp_list $item " ;;
		esac
	done

	echo $temp_list
}

clean_build_only_list () {
	local dep temp_bodlg

	for dep in $build_only_dl_g; do
		case "$run_dl_g" in
		*" ${dep} "*)	;;
		*)	temp_bodlg="$temp_bodlg $dep" ;;
		esac
	done

	build_only_dl_g=" `uniquify_list $temp_bodlg` "
}

gen_dep_list () {
	local list

	if [ -z "$PM_INDEX_ONLY" ]; then
		pm_cd_pd $portdir
		list=`pm_make $* | sort -u`
	else
		local temp_list l

		case "$*" in
		'build-depends-list run-depends-list'|all-depends-list)
			temp_list="`parse_index $portdir b-deps` `parse_index $portdir r-deps`" ;;
		build-depends-list) temp_list=`parse_index $portdir b-deps` ;;
		run-depends-list) temp_list=`parse_index $portdir r-deps` ;;
		esac

		temp_list=`uniquify_list $temp_list`

		for l in $temp_list ; do
			list="$list `grep -m1 ^${l}\| $PM_INDEX | cut -f 2 -d \|`"
		done

		list=" $list "
	fi

	echo "$list"
}

dependency_check () {
	# Global: doing_dep_check
	# Global: run_dl_g build_only_dl_g

	local d_port_list

	# Print a message here because sometimes list generation takes
	# a long time to return.
	if [ -z "$PM_INDEX_ONLY" ]; then
		echo "===>>> Gathering dependency list for $portdir from ports"
	else
		echo "===>>> Gathering dependency list for $portdir from ${PM_INDEX##*/}"
	fi
	d_port_list=`gen_dep_list $1`

	if [ -z "$d_port_list" ]; then
		echo "===>>> No dependencies for $portdir"
		[ -n "$SHOW_WORK" ] && safe_exit
		return 0
	else
		if [ -n "$SHOW_WORK" ]; then
			echo ''
		else
			pm_v "===>>> Starting dependency check"
		fi
	fi

	if [ "$PM_BUILD_ONLY_LIST" = pmp_doing_build_deps ]; then
		local rundeps dep varname run_dl build_only_dl

		rundeps=`gen_dep_list run-depends-list`

		for dep in $d_port_list; do
			case "$rundeps" in
			*" ${dep} "*|*${dep}*)
				varname=`echo ${dep#$pd/} | sed 's#[-+/\.]#_#g'`
				rundep_list="$rundep_list $varname"
				eval $varname=\"$portdir \$$varname\"
				eval ${varname}_p=$dep
				eval export $varname ${varname}_p

				run_dl="$run_dl $dep" ;;
			*)	build_only_dl="$build_only_dl $dep" ;;
			esac
		done

		if [ -z "$RECURSE_THOROUGH" ]; then
			d_port_list="$build_only_dl $run_dl"
		else
			build_only_dl=`gen_dep_list build-depends-list`
		fi

		run_dl_g="$run_dl_g $run_dl "

		for dep in $build_only_dl; do
			case "$build_only_dl_g" in
			*" ${dep} "*)	;;
			*) build_only_dl_g="$build_only_dl_g $dep " ;;
			esac
		done

		clean_build_only_list
	fi

	local d_port origin iport

	# Do not export, for THIS parent process only
	[ -n "$PM_FIRST_PASS" ] && doing_dep_check=doing_dep_check
	for d_port in $d_port_list; do
		origin="${d_port#$pd/}"
		if [ -n "$SHOW_WORK" ]; then
			iport=`iport_from_origin $origin`
			case "$iport" in
			'') echo "===>>> NOT INSTALLED		$origin" ;;
			*)  echo "===>>> Installed $origin" ;;
			esac
			continue
		fi

		pm_v "===>>> Checking dependency: $origin"

		# Do this first to catch out of date dependencies
		[ -n "$PM_FIRST_PASS" ] &&
			case "$PM_NEEDS_UPDATE" in *\ $origin\ *) continue ;; esac

		[ -z "$URB_YES" ] &&
			case "$CUR_DEPS" in *:${origin}:*) continue ;; esac

		if [ -z "$PM_INDEX_ONLY" ]; then
			local conflicts glob confl_p

			conflicts=''
			if pm_cd $d_port; then
				grep -ql ^CONFLICTS Makefile &&
					conflicts=`pm_make_b -V CONFLICTS`
			else
				fail "Cannot cd to $d_port"
			fi
			for glob in $conflicts; do
				confl_p=`pkg_info -I $glob 2>/dev/null`
				if [ -n "$confl_p" ]; then
					confl_p=${confl_p%% *}
					echo ''
					echo "===>>> The dependency for ${origin}"
					echo "       seems to be handled by $confl_p"
					echo ''
					d_port="$pd/`origin_from_pdb $confl_p`"
				fi
			done
		fi

		# In case d_port changed above
		origin="${d_port#$pd/}" ; iport=`iport_from_origin ${origin}`

		check_exclude ${iport:-$origin} || continue

		if [ -n "$PM_FORCE" -a -n "$iport" ]; then
			if ! check_restart_and_udf $iport; then
				echo "===>>> Forcing update for $pd/$origin"
				update_port $iport
			else
				CUR_DEPS="${CUR_DEPS}${iport}:${origin}:"
			fi
			continue
		elif [ -n "$URB_YES" -a -n "$iport" ]; then
			case "$URB_DONE_LIST" in
			*:${iport}:*) already_done $iport ; continue ;; esac

			case "$MASTER_RB_LIST" in *" $iport "*)
				check_interactive $iport || continue
				if ! check_restart_and_udf $iport; then
					update_port $iport
				else
					CUR_DEPS="${CUR_DEPS}${iport}:${origin}:"
					URB_DONE_LIST="${URB_DONE_LIST}${upg_port}:"
				fi
				continue ;;
			esac
		fi

		if [ -n "$iport" ]; then
			# No check_interactive here because we want to tell
			# the user whether or not there is a new version first
			check_for_updates $iport $origin || fail 'Update failed'
		else
			check_interactive $origin || continue
			update_port $origin
		fi
	done
	[ -n "$PM_FIRST_PASS" ] && unset doing_dep_check

	if [ -n "$SHOW_WORK" ]; then
		safe_exit
	elif [ -n "$PM_FIRST_PASS" -a -z "$PM_PACKAGES" ]; then
		echo "===>>> Initial dependency check complete for $portdir"
		case "$PM_DEPTH" in *\>\>*) echo "	$PM_DEPTH" ;; esac
	else
		echo "===>>> Dependency check complete for $portdir"
		case "$PM_DEPTH" in
		*\>\>*)	echo "	$PM_DEPTH" ;;
		*)	if [ "$PM_PARENT_PORT" = All ]; then
				local deps
				deps=" (${dep_of_deps}/${num_of_deps})"
				term_printf " >> ${upg_port:-$portdir}${deps}"
			else
				term_printf
			fi ;;
		esac
	fi
}

create_master_rb_list () {
	# Global: MASTER_RB_LIST
	local req_by

	for req_by in `grep -l DEPORIGIN:$portdir$ $pdb/*/+CONTENTS`; do
		req_by="${req_by%/+CONTENTS}"
		req_by="${req_by##*/}"
		MASTER_RB_LIST="${MASTER_RB_LIST}${req_by} "
	done

	[ -n "$MASTER_RB_LIST" ] && export MASTER_RB_LIST=" $MASTER_RB_LIST"
}

post_first_pass () {
	local action

	if [ -n "$UPDATE_REQ_BYS" -a -n "$RESTART" ]; then
		if [ -n "$PM_RBP_NEEDS_UPGRADE" ]; then
			echo "===>>> $PM_RBP and/or dependencies are out of date, forcing rebuild"
		else
			echo "===>>> $PM_RBP is up to date, skipping rebuild due to -R flag"
			PM_REQ_BY_SKIP_PARENT=pm_req_by_skip_parent
			build_l="${build_l#*\\n}"
		fi
		echo ''
	fi

	if [ $num_of_deps -gt 0 ]; then
		term_printf " (${num_of_deps})"

		if [ -z "$PM_NO_CONFIRM" ]; then
			local answer

			echo ''
			echo "===>>> The following actions will be taken if you choose to proceed:"
			echo -e "$build_l"
			echo -n "===>>> Proceed? y/n [y] "
			read answer
			case "$answer" in
			[yY]|'')	;;
			*)	echo ''
				echo "===>>> If you would like to upgrade or install some, but not"
				echo "       all of the above try adding '-i' to the command line."
				safe_exit 1 ;;
			esac
			unset build_l
		fi
	else
		term_printf
	fi

	# Only when -a or multi and user said no to update +IGNOREME(s)
	[ "$PM_NEEDS_UPDATE" = ' ' ] && return

	action=build
	if [ "$PM_PACKAGES" = only ]; then
		action=install
	elif [ -n "$PM_PACKAGES" ]; then
		action='build and/or install'
	fi

	echo ''; echo "===>>> Starting $action for $* <<<==="; echo ''

	unset PM_FIRST_PASS PM_NO_CONFIRM

	dep_of_deps=0

	if [ -n "$PM_BUILD_ONLY_LIST" ]; then
		local var real_rundep deplist dep temp_bodlg

		for var in $rundep_list ; do
			real_rundep=no

			eval deplist=\$$var
			for dep in $deplist ; do
				case "$build_only_dl_g" in
				*" $pd/$dep "*) ;;
				*)	real_rundep=yes ; break ;;
				esac
			done

			[ "$real_rundep" = 'no' ] &&
				eval build_only_dl_g=\"${build_only_dl_g}\$${var}_p \"
			eval unset $var ${var}_p
		done

		for dep in $build_only_dl_g; do
			grep -q "@comment DEPORIGIN:${dep#$pd/}$" $pdb/*/+CONTENTS ||
				temp_bodlg="$temp_bodlg $dep"
		done

		build_only_dl_g=" `uniquify_list $temp_bodlg` "

		unset run_dl_g rundep_list
		PM_BUILD_ONLY_LIST=pm_bol
	fi
}

init_term_printf () {
	PM_PARENT_PORT=$1
	[ -z "$num_of_deps" ] && num_of_deps=0
	[ -z "$dep_of_deps" ] && dep_of_deps=0
	export PM_PARENT_PORT num_of_deps dep_of_deps

	term_printf
}

multiport () {
	# Global
	PM_MULTI_PORTS=':' ; export PM_MULTI_PORTS

	local port worklist_temp worklist portlist numports origin num

	# Expand globs and check that the directories exist
	for port in "$@"; do
		port=${port#$pdb/}
		case "$port" in
		*/*)	port=${port#$pd/}
			if [ -d "$pd/${port}" ]; then
				worklist_temp="$worklist_temp $port"
			else
				fail "$pd/${port} does not exist"
			fi ;;
		*)	if [ -d "$pdb/$port" ]; then
				worklist_temp="$worklist_temp $port"
			else
				find_glob_dirs $port
				case $? in
				1)	fail "$pdb/$port does not exist" ;;
				*)	local dir
					for dir in $glob_dirs; do
					worklist_temp="$worklist_temp ${dir#$pdb/}"
					done ;;
				esac
				unset glob_dirs
			fi ;;
		esac
	done

	for port in $worklist_temp; do
		check_exclude $port || continue
		check_interactive $port || continue

		worklist="$worklist $port"
		portlist="${portlist}\t${port}\n"
		PM_MULTI_PORTS="${PM_MULTI_PORTS}${port}:"
	done

	echo "===>>> Working on multiple ports:"
	echo -e $portlist

	if [ -n "$PM_FIRST_PASS" ]; then
		if [ -n "$PM_BUILD_ONLY_LIST" ]; then
			PM_BUILD_ONLY_LIST=pmp_doing_build_deps
			for port in $worklist; do
				case "$port" in
				*/*)	run_dl_g="$run_dl_g ${pd}/${port} " ;;
				*)	run_dl_g="$run_dl_g ${pd}/`origin_from_pdb $port` " ;;
				esac
			done
		fi

		numports=0
		for port in $worklist; do
			case "$port" in
			*/*)	origin=$port ;;
			*)	origin=`origin_from_pdb $port` ;;
			esac

			case "$PM_NEEDS_UPDATE" in *\ $origin\ *) continue ;; esac

			numports=$(( $numports + 1 ))
			init_term_printf "$port ${numports}/${numports}"
			($0 $ARGS $port) || fail "Update for $port failed"
			. $IPC_SAVE

			case "$PM_NEEDS_UPDATE" in
			*\ $origin\ *)		continue ;;
						# Handle +IGNOREME in child
			*)			numports=$(( $numports - 1 )) ;;
			esac
		done

		check_fetch_only
		post_first_pass multiple ports
	fi

	export PM_BUILDING=pmbuildingmultiport
	num=0
	for port in $worklist; do
		case "$port" in
		*/*)	origin=$port ;;
		*)	# If an installed version does not exist at this
			# point it probably got updated as a dependency
			if [ ! -d "$pdb/$port" ]; then
				numports=$(( $numports - 1 ))
				continue
			fi
			origin=`origin_from_pdb $port` ;;
		esac

		case "$PM_NEEDS_UPDATE" in
		*\ $origin\ *)	;;		# Ok to proceed
		*)		continue ;;	# Already updated as a dependency
		esac

		num=$(( $num + 1 ))
		init_term_printf "$port ${num}/${numports}"
		($0 $ARGS $port) || fail "Update for $port failed"
		. $IPC_SAVE
	done
	safe_exit
}

make_config () {
	local config_type

	config_type=config-conditional
	[ -n "$PM_FORCE_CONFIG" ] && config_type=config
	pm_sv Running \'make $config_type\'
	pm_cd_pd $portdir
	pm_make_s $config_type
}

urb_final () {
	# Global: URB_YES
	local req_by

	export URB_YES=urb_yes_final
	echo "===>>> Updating ports that depend on $new_port"
	echo ''
	create_master_rb_list
	for req_by in $MASTER_RB_LIST; do
		# Probably not needed, but JIC
		[ -d "$pdb/$req_by" ] || continue

		case "$URB_DONE_LIST" in
		*:${req_by}:*) already_done $req_by ; continue ;;
		esac

		# Check here since if "no" it will not prompt
		check_interactive $req_by || continue

		pm_v "===>>> $new_port is required by $req_by"
		check_exclude $req_by || continue

		# Shortcut, since check_for will force it
		if [ -z "$RESTART" -a -z "$PM_FORCE" ]; then
			update_port $req_by
		else
			check_for_updates $req_by || fail 'Update failed'
		fi
		echo "===>>> Returning to check of ports depending on $upg_port"
	done
	echo ''
	echo "===>>> Done updating ports that depend on $new_port"
	echo ''

	safe_exit
}

#=============== End functions for main ===============

# INIT Parent

if [ "$$" -eq "$PM_PARENT_PID" -a -z "$SHOW_WORK" ]; then
	CUR_DEPS=':' ; DISPLAY_LIST='' ; INSTALLED_LIST=''
	PM_DEPTH='' ; IPC_SAVE=`pm_mktemp IPC_SAVE`
	export CUR_DEPS DISPLAY_LIST INSTALLED_LIST PM_DEPTH IPC_SAVE

	if [ -n "$LOCALBASE" ]; then
		LOCALBASE_COMPAT="$LOCALBASE/lib/compat/pkg"
	elif [ -z "$FETCH_ONLY" ]; then
		PLB=`pm_make_b -f/usr/share/mk/bsd.port.mk -V LOCALBASE 2>/dev/null`
		if [ -n "$PLB" ]; then
			LOCALBASE_COMPAT="$PLB/lib/compat/pkg"
		else
			[ -n "$PM_INDEX" ] && PLB=`head -1 $PM_INDEX | cut -f 3 -d\| 2>/dev/null`
			if [ -n "$PLB" ] && [ -d "$PLB" ]; then
				LOCALBASE_COMPAT="${PLB}/lib/compat/pkg"
			else
				echo "===>>> Unable to determine the value of LOCALBASE"
				echo "       Try setting it in the environment, or /etc/make.conf"
				fail 'The value of LOCALBASE cannot be empty'
			fi
		fi
		unset PLB
	fi
	export LOCALBASE_COMPAT

	if [ -n "$INTERACTIVE_UPDATE" ]; then
		INTERACTIVE_YES=':' ; INTERACTIVE_NO=':'
		export INTERACTIVE_YES INTERACTIVE_NO
	fi

	[ -n "$UPDATE_REQ_BYS" ] && export URB_DONE_LIST=':'
	if [ -n "$UPDATE_REQ_BYS" -o -n "$PM_FORCE" ]; then
		if [ -z "$RESTART" ]; then
			files=`find $pdb -type f -name PM_UPGRADE_DONE_FLAG`
			if [ -n "$files" ]; then
				echo "===>>> There are 'install complete' flags from a previous"
				echo -n "       -[rf] run of ${0##*/}, delete them? y/n [n] "
				read answer
				case "$answer" in
				[yY])	pm_sv Deleting \'install complete\' flags
					pm_find_s $pdb -type f -name PM_UPGRADE_DONE_FLAG -delete ;;
				*)	echo -n "===>>> Enable the -R option? y/n [n] "
					read answer
					case "$answer" in
					[yY]) RESTART=Ropt ; ARGS="-R $ARGS" ;;
					esac ;;
				esac
			fi
		fi
	fi

	PM_FIRST_PASS=pm_first_pass ; export PM_FIRST_PASS

	if [ -z "$FETCH_ONLY" ]; then
		PM_NEEDS_UPDATE=' ' ; NO_DEP_UPDATES=no_dep_updates ; build_l=''
		export PM_NEEDS_UPDATE NO_DEP_UPDATES build_l
	fi

	if [ -n "$PM_BUILD_ONLY_LIST" ]; then
		run_dl_g='' ; build_only_dl_g='' ; rundep_list=''
		export run_dl_g build_only_dl_g rundep_list
	fi
	if [ -n "$PM_DEL_BUILD_ONLY" ]; then
		build_deps_il='' ; export build_deps_il
	fi

	[ -z "$NO_BACKUP" ] && init_packages
	[ -z "$NO_BACKUP" -a -z "$BACKUP" ] && export NB_DELETE
	if [ -n "$MAKE_PACKAGE" -a -z "$FETCH_ONLY" ]; then
		init_packages_var

		if [ ! -d "$PACKAGES" ]; then
			pm_sv Creating $PACKAGES
			pm_mkdir_s $PACKAGES
		fi
	fi

	# Set the file name here so it's visible to the children
	[ -z "$DONT_SCRUB_DISTFILES" -a -z "$FETCH_ONLY" -a -z "$PM_PACKAGES" ] &&
		export DI_FILES=`pm_mktemp DI-FILES`

	[ $# -gt 1 -a -z "$REPLACE_ORIGIN" ] && multiport "$@"
fi

# This has to come after the initialization, it uses all the same stuff
if [ -n "$UPDATE_ALL" ]; then
all_first_pass () {
	local iport origin

	for iport in "$@"; do
		pm_v "===>>> $iport"

		case "$CUR_DEPS" in *:${iport}:*) continue ;; esac

		origin=`origin_from_pdb $iport` || {
			case "$?" in
			3) ;;
			2)	pm_v "	===>>> No ORIGIN for $iport, and +IGNOREME is present"
				echo "	===>>> Skipping"
				echo '' ;;
			*)	fail 'Cannot continue' ;;
			esac;

			# Prevent the user from getting reprompted during build
			CUR_DEPS="${CUR_DEPS}${iport}:";
			continue; }

		case "$PM_NEEDS_UPDATE" in *\ $origin\ *) continue ;; esac

		[ -n "$PM_BUILD_ONLY_LIST" ] && run_dl_g="$run_dl_g ${pd}/${origin} "

		check_exclude $iport || continue

		PM_DEPTH=
		check_for_updates $iport $origin || fail 'Update failed'
	done
}
	[ -n "$DI_FILES" ] && (read_distinfos)&

	init_term_printf All

	ports_by_category
	echo "===>>> Starting check of installed ports for available updates"

	[ -n "$PM_BUILD_ONLY_LIST" ] && PM_BUILD_ONLY_LIST=pmp_doing_build_deps

	if [ -n "$PM_FIRST_PASS" ]; then
		[ -n "$FETCH_ONLY" ] && export ALL_FETCH=all_fetch

		pm_v ; pm_v "===>>> Root ports:"
		all_first_pass $roots

		pm_v ; pm_v "===>>> Trunk ports:"
		all_first_pass $trunks

		pm_v ; pm_v "===>>> Branch ports:"
		all_first_pass $branches

		pm_v ; pm_v "===>>> Leaf ports:"
		all_first_pass $leaves

		check_fetch_only
		if [ -n "$NO_DEP_UPDATES" ]; then
			echo '' ; echo "===>>> All ports are up to date" ; echo ''
			safe_exit
		fi

		post_first_pass 'for ports that need updating'

		[ -n "$PM_BUILD_ONLY_LIST" ] && clean_build_only_list
	fi

	export PM_BUILDING=pmbuildingall

	unset roots trunks branches leaves

	for origin in $PM_NEEDS_UPDATE; do
		case "$PM_NEEDS_UPDATE" in
		*\ $origin\ *)	update_port $origin ;;
		*)		continue ;;	# Already updated as a dependency
		esac
	done

	echo "===>>> Update check of installed ports complete" ; echo ''
	safe_exit
fi	# [ -n "$UPDATE_ALL" ]

no_valid_port () {
	echo "===>>> No valid installed port, or port directory given"
	echo "===>>> Try ${0##*/} --help" ; echo '' ; safe_exit 1
}

# Figure out what we are going to be working on
if [ -z "$REPLACE_ORIGIN" ]; then
	[ -n "$portdir" ] && { argv=$portdir ; unset portdir; }
	argv=${argv:-$1} ; argv=${argv%/} ; argv=`globstrip $argv`
	case "$argv" in
	'')	echo '' ; no_valid_port ;;
	$pd/*)	portdir=${argv#$pd/} ;;
	$pdb/*)	upg_port=${argv#$pdb/} ;;
	/*)	echo '' ; no_valid_port ;;
	*/*)	portdir=$argv ;;
	\.)	portdir=${PWD##*/ports/} ;; # Not always $pd, could be symlink
	*)	[ -d "$pdb/$argv" ] && upg_port=$argv ;;
	esac

	if [ -z "$portdir" -a -z "$upg_port" ]; then
		find_glob_dirs $argv
		case $? in
		1)	echo '' ; no_valid_port ;;
		2)	multiport $glob_dirs ;;
		0)	upg_port=${glob_dirs#$pdb/} ;;
		esac
		unset glob_dirs
	fi
else
	portdir="${1#$pd/}" ; portdir="${portdir%/}"
	if [ ! -d "$pd/$portdir" ]; then
		echo ''
		echo "===>>> The first argument to -o must be a directory in $pd"
		echo '' ; no_valid_port
	fi

	upg_port=`iport_from_origin $portdir`

	arg2=${2#$pd/} ; arg2=${arg2#$pdb/} ; arg2=${arg2%/}

	case "$arg2" in
	*/*)	ro_opd=$arg2 ; ro_upg_port=`iport_from_origin $ro_opd` ;;
	*)	if [ -d "$pdb/$arg2" ]; then
			ro_upg_port=$arg2
		else
			find_glob_dirs $arg2 && ro_upg_port=${glob_dirs#$pdb/}
			unset glob_dirs
		fi
		[ -n "$ro_upg_port" ] && ro_opd=`origin_from_pdb $ro_upg_port`
	esac
	unset arg2

	if [ -z "$ro_upg_port" ]; then
		if ! grep -ql "DEPORIGIN:$ro_opd$" $pdb/*/+CONTENTS; then
			echo ''
			echo "===>>> The second argument to -o can be a port in $pdb,"
			echo "       or a port directory from $pd"
			echo ''
			echo "       $ro_opd does not seem to be installed,"
			echo '       or listed as a dependency'
			echo '' ; no_valid_port
		fi
	fi

	PM_MAKE_ARGS="-DDISABLE_CONFLICTS $PM_MAKE_ARGS"
fi

if [ -n "$upg_port" -a -z "$portdir" ]; then
	portdir=`origin_from_pdb $upg_port` || {
	case "$?" in
	3)	echo ''; echo "===>>> BSDPAN ports cannot be upgraded with portmaster"
		echo "       (${upg_port})"; echo ''; safe_exit 1 ;;
	2)	pm_v "	===>>> No ORIGIN for $upg_port, and +IGNOREME is present"; pm_v
		safe_exit 1 ;;
	*)	fail 'Cannot continue' ;;
	esac ; }
elif [ -z "$portdir" ]; then
	no_valid_port
fi

if [ ! -d "$pd/$portdir" -a -z "$PM_INDEX_ONLY" ]; then
	find_moved_port $portdir $upg_port || no_valid_port
	[ -n "$moved_npd" ] || no_valid_port
	[ -d "$pd/$moved_npd" ] || no_valid_port

	[ "$$" -eq "$PM_PARENT_PID" ] && parent_exit
	exec $0 $ARGS -o $moved_npd $upg_port
fi
[ -z "$upg_port" -a -z "$REPLACE_ORIGIN" ] && upg_port=`iport_from_origin ${portdir}`

if [ -e "$pdb/$upg_port/+IGNOREME" ]; then
	# Adding to CUR_DEPS means we will not get here in the build unless -G
	if [ -z "$PM_BUILDING" ]; then
		# Only need to prompt for this once if -ai
		case "$INTERACTIVE_YES" in
		*:${upg_port}:*) ;;	# Let it build
		*)	if [ -z "$FETCH_ONLY" ]; then
				echo ''
				echo "===>>> $upg_port has an +IGNOREME file"
				echo ''
				echo -n "===>>> Update anyway? y/n [n] "
				read answer
				case "$answer" in
				[yY]) ;;	# Let it build
				*)	CUR_DEPS="${CUR_DEPS}${upg_port}:${portdir}:"
					if [ ${dep_of_deps:-0} -gt 0 ]; then
						dep_of_deps=$(( $dep_of_deps - 1 ))
						[ -n "$PM_FIRST_PASS" ] &&
							num_of_deps=$(( $num_of_deps - 1 ))
					fi
					safe_exit ;;
				esac
			else
				echo ''
				echo "===>>> $upg_port has an +IGNOREME file, ignoring"
				echo ''
				CUR_DEPS="${CUR_DEPS}${upg_port}:${portdir}:"
				safe_exit
			fi ;;
		esac
	elif [ -n "$URB_YES" ]; then
		echo ''
		echo "===>>> $upg_port has an +IGNOREME file, ignoring"
		echo ''
		safe_exit
	fi
fi

# START

if [ -z "$PM_INDEX_ONLY" ]; then
	pm_cd $pd/$portdir || no_valid_port
else
	new_port=`parse_index $portdir name` ||
		fail "No entry for $portdir in $PM_INDEX"
fi

if [ -z "$PM_DEPTH" ]; then
	PM_DEPTH="${upg_port:-$portdir} "
	[ -z "$PM_PARENT_PORT" ] && init_term_printf ${upg_port:-$portdir}
else
	PM_DEPTH="${PM_DEPTH}>> ${upg_port:-$portdir} "
fi

echo ''
[ "$$" -eq "$PM_PARENT_PID" -a -n "$upg_port" ] &&
	echo "===>>> Currently installed version: $upg_port"

echo "===>>> Port directory: $pd/$portdir" ; echo ''

if [ -n "$PM_FIRST_PASS" -a -z "$FETCH_ONLY" ]; then
	if [ -z "$PM_INDEX_ONLY" ]; then
		if ! check_state; then
			echo "	===>>> If you are sure you can build it, remove the"
			echo "	       $state line in the Makefile and try again."
			safe_exit 1
		fi
	fi

	if [ -n "$upg_port" ]; then
		update_build_l $upg_port
		[ -n "$UPDATE_REQ_BYS" -a -n "$RESTART" -a "$$" -eq "$PM_PARENT_PID" ] &&
			check_for_updates $upg_port
	else
		update_build_l $portdir
	fi
fi

# Do these things first time through
if [ -z "$PM_INDEX_ONLY" -a -z "$PM_BUILDING" -a -z "$SHOW_WORK" -a -z "$NO_ACTION" ]; then
	# Do not start this in the background until we are sure we are going to build
	[ "$$" -eq "$PM_PARENT_PID" -a -n "$DI_FILES" ] && (read_distinfos)&

	# Handle the problem of manual fetching
	[ -z "$PM_PACKAGES" ] && master_sites=`pm_make -V MASTER_SITES`

	if [ -n "$master_sites" ]; then
		# PATCHFILES may get added after the first pass, but we want to
		# do as much of this as we can, as early as we can, and
		# patch files are usually small anyway.
		distfiles=`pm_make -V ALLFILES | sed -e 's# *$##g'`
		[ -n "$distfiles" ] && distfiles=" ${distfiles} "

		# Make sure that different ports using the same distfiles
		# do not clobber each other's fetchs
		for file in $distfiles; do
			case "$file" in */*) file=`echo $file | sed s#/#_#g` ;; esac
			if ! ls ${TMPDIR}/f-${PM_PARENT_PID}-${file}-* >/dev/null 2>&1; then
				pm_mktemp ${file}-${portdir#*/} >/dev/null
			else
				DONT_FETCH=dont_fetch
				break
			fi
		done

		if [ -z "$DONT_FETCH" -a -n "$distfiles" ]; then
			echo "===>>> Launching 'make checksum' for $portdir in background"
			fetchlog=`pm_mktemp fetchlog-${portdir#*/}`
			(pm_make -DBATCH checksum >> $fetchlog 2>&1 && {
			    rm -f ${TMPDIR}/f-${PM_PARENT_PID}-*-${portdir#*/}.*; exit 0; }
			    allfiles=`pm_make -V ALLFILES`
			    pm_make delete-distfiles RESTRICTED_FILES="${allfiles}" \
				>> $fetchlog 2>&1 &&
				    echo "===>>> RE-STARTING FETCH <<<===" >> $fetchlog
			    pm_make -DBATCH checksum >> $fetchlog 2>&1
			    rm -f ${TMPDIR}/f-${PM_PARENT_PID}-*-${portdir#*/}.* )&
		fi
		unset master_sites distfiles file DONT_FETCH fetchlog allfiles
	fi

	if [ -z "$FETCH_ONLY" -a ! "$PM_PACKAGES" = only ]; then
		TESTINT=`grep -l ^IS_INTERACTIVE Makefile`
	else
		[ -n "$ALL_FETCH" ] && safe_exit
	fi
	if [ -n "$TESTINT" ]; then
		echo ''
		echo "===>>> Warning: $portdir is interactive, and will likely"
		echo "       require attention during the build"
		echo ''
		echo -n "===>>> Press the [Enter] or [Return] key to continue "
		read DISCARD
		echo ''
		unset TESTINT DISCARD
	fi
fi	# [ -z "$PM_INDEX_ONLY" -a -z "$PM_BUILDING" -a -z "$SHOW_WORK" -a -z "$NO_ACTION" ]

if [ -n "$PM_FIRST_PASS" ]; then
	[ "$$" -eq "$PM_PARENT_PID" -a -n "$PM_BUILD_ONLY_LIST" ] &&
		PM_BUILD_ONLY_LIST=pmp_doing_build_deps

	if [ -z "$PM_PACKAGES" ]; then
		[ -z "$PM_NO_MAKE_CONFIG" ] && make_config

		dep_check_type='build-depends-list run-depends-list'
		[ -n "$RECURSE_THOROUGH" ] && dep_check_type=all-depends-list
	else
		dep_check_type=run-depends-list
	fi

	dependency_check "$dep_check_type"

	[ -n "$UPDATE_REQ_BYS" -o -n "$URB_YES" ] &&
		URB_DONE_LIST="${URB_DONE_LIST}${upg_port}:"

	if [ ! "$$" -eq "$PM_PARENT_PID" ]; then
		# Save state for the parent process to read back in
		> $IPC_SAVE
		if [ "$PM_BUILD_ONLY_LIST" = pmp_doing_build_deps ]; then
			echo "build_only_dl_g='$build_only_dl_g'" >> $IPC_SAVE
			echo "run_dl_g='$run_dl_g'" >> $IPC_SAVE
			rundep_list=`uniquify_list $rundep_list`
			echo "rundep_list='$rundep_list'" >> $IPC_SAVE
			for f in $rundep_list; do
				eval echo "export $f=\'\$$f\'" >> $IPC_SAVE
				eval echo "export ${f}_p=\'\$${f}_p\'" >> $IPC_SAVE
			done
		fi

		safe_exit
	elif [ -n "$UPDATE_REQ_BYS" ]; then
		[ -z "$NO_DEP_UPDATES" ] && PM_RBP_NEEDS_UPGRADE=pm_rbp_needs_upgrade
		export URB_YES=urb_yes
		echo ''
		echo "===>>> Checking ports that depend on $upg_port"
		echo ''
		create_master_rb_list
		[ -n "$MASTER_RB_LIST" ] || {
			echo "===>>> No ports depend on $upg_port" ; echo ''; }
		for req_by in $MASTER_RB_LIST; do
			# Probably not needed, but JIC
			[ -d "$pdb/$req_by" ] || continue

			case "$URB_DONE_LIST" in
			*:${req_by}:*) already_done $req_by
			continue ;; esac

			pm_v "===>>> $upg_port is required by $req_by"

			check_exclude $req_by || continue
			check_interactive $req_by || continue

			# Shortcut, since check_for will force it
			if [ -z "$RESTART" -a -z "$PM_FORCE" ]; then
				update_port $req_by
			else
				check_for_updates $req_by || fail 'Update failed'
			fi
			echo "===>>> Returning to check of ports depending on $upg_port"
		done
		echo ''
		echo "===>>> Done checking ports that depend on $upg_port"
		echo ''
		unset URB_YES MASTER_RB_LIST ; URB_DONE_LIST=':'
	fi

	check_fetch_only
	post_first_pass $portdir
fi	# [ -n "$PM_FIRST_PASS" ]

[ -z "$PM_BUILDING" ] && export PM_BUILDING=pmbuildingmain

pm_cd_pd $portdir

if [ -n "$PM_BUILD_ONLY_LIST" ]; then
	case "$build_only_dl_g" in
	*" $pd/$portdir "*)
		[ -n "$PM_PACKAGES_BUILD" ] && PM_PACKAGES_BUILD=doing_build_only_dep
		[ -n "$PM_DEL_BUILD_ONLY" ] && PM_DEL_BUILD_ONLY=doing_build_only_dep ;;
	*)	[ -n "$PM_PACKAGES_BUILD" ] && PM_PACKAGES_BUILD=pmp_build
		[ -n "$PM_DEL_BUILD_ONLY" ] && PM_DEL_BUILD_ONLY=pm_dbo ;;
	esac
fi

if [ -z "$NO_DEP_UPDATES" ]; then
	if [ -z "$RECURSE_THOROUGH" ]; then
		if [ -z "$PM_PACKAGES" ]; then
			echo "===>>> Starting check for build dependencies"
			dependency_check build-depends-list
		fi
	else
		echo "===>>> Starting check for all dependencies"

		if [ -z "$PM_PACKAGES" ]; then
			dependency_check all-depends-list
		else
			dependency_check run-depends-list
		fi
	fi
	pm_cd_pd $portdir
elif [ "$$" -eq "$PM_PARENT_PID" ]; then
	echo "===>>> All dependencies are up to date"
	echo ''
fi

if [ -n "$NO_ACTION" -a -z "$PM_FIRST_PASS" ]; then
	pm_v "===>>> Build canceled due to -n flag"
	safe_exit
fi

if [ -z "$new_port" ]; then
	if [ -z "$PM_INDEX_ONLY" ]; then
		new_port=`pm_make -V PKGNAME`
	else
		new_port=`parse_index $portdir name` ||
			fail "No entry for $origin in $PM_INDEX"
	fi
fi

[ -n "$PM_REQ_BY_SKIP_PARENT" ] && urb_final

if [ -n "$PM_PACKAGES" -o "$PM_PACKAGES_BUILD" = doing_build_only_dep ]; then
fetch_package () {
	local do_fetch

	if [ -z "$ppd" ]; then
		init_packages_var
		ppd=$PACKAGES/portmaster-download
		export ppd
	fi

	[ -d "$ppd" ] || { pm_sv Creating $ppd; pm_mkdir_s $ppd; }

	if [ -z "$FETCH_ARGS" ]; then
		FETCH_ARGS=`pm_make -f/usr/share/mk/bsd.port.mk -V FETCH_ARGS 2>/dev/null`
		[ -n "$FETCH_ARGS" ] || FETCH_ARGS='-ApRr'
		export FETCH_ARGS
	fi

	if [ -z "$PM_ALWAYS_FETCH" ]; then
		if [ -r "${ppd}/${1}.tbz" ]; then
			pm_v "===>>> Package exists, skipping fetch"
			return 0
		else
			do_fetch=do_fetch_no_package
		fi
	else
		do_fetch=do_fetch_always_fetch
	fi

	if [ -n "$do_fetch" ]; then
		if [ -n "$PM_VERBOSE" ]; then
			if [ -n "$2" ]; then
				echo "===>>> Trying to fetch $1 directly"
			else
				echo "===>>> Starting package fetch"
			fi
		fi

		pm_sv Fetching ${1}.tbz
		if ! $PM_SU_CMD fetch $FETCH_ARGS -o $ppd ${sitepath}${1}.tbz 2>/dev/null; then
			pm_unlink_s ${ppd}/${1}.tbz
			$PM_SU_CMD fetch $FETCH_ARGS -o $ppd ${sitepath}${1}.tbz 2>/dev/null
		fi
	fi
}
	if [ -z "$PACKAGESITE" -a -z "$PM_PACKAGES_LOCAL" ]; then
		release=`uname -r`

		case "$release" in
		[678]\.[0-9]-STABLE|[678]\.[0-9]-PRERELEASE)
				release=packages-${release%%\.*}-stable ;;
		[678]\.[0-9]-RELEASE*)
				release=packages-${release%-RELEASE*}-release ;;
		9\.0-CURRENT*)	release=packages-9-current ;;
		*RC[0-9]*)	release=${release%-RC[0-9]}
				release=packages-${release}-release ;;
		*BETA[0-9]*)	release=${release%-BETA[0-9]}
				release=packages-${release}-release ;;
		esac

		sitepath="${PACKAGEROOT:-"http://ftp.freebsd.org"}/pub/FreeBSD/ports/`uname -p`/${release}/"
		unset release
	else
		sitepath="${PACKAGESITE%/}"
		sitepath="${sitepath%Latest}"
		sitepath="${sitepath%All}"
	fi

	sitepath="${sitepath%/}/${portdir%/*}/"

	echo "===>>> Checking package repository for latest available version"

	if [ -n "$LOCAL_PACKAGEDIR" ]; then
		if [ -r "${LOCAL_PACKAGEDIR}/All/${new_port}.tbz" ]; then
			local_package=${LOCAL_PACKAGEDIR}/All/${new_port}.tbz
			latest_pv=${local_package##*/}
		fi
		if [ -z "$latest_pv" -a -z "$PM_INDEX_ONLY" ]; then
			s=`pm_make -V LATEST_LINK`
			if [ -r "${LOCAL_PACKAGEDIR}/Latest/${s}.tbz" ]; then
				local_package=${LOCAL_PACKAGEDIR}/Latest/${s}.tbz
				latest_pv=`readlink ${LOCAL_PACKAGEDIR}/Latest/${s}.tbz`
				latest_pv=${latest_pv##*/}
			else
				pm_v "===>>> No local package for ${new_port}, attempting fetch"
			fi
		fi
	fi

	if [ -z "$latest_pv" -a -z "$PM_PACKAGES_LOCAL" ]; then
		dirlist=`echo ${TMPDIR}/f-${PM_PARENT_PID}-dl-${portdir%/*}\.*`
		if [ ! -r "$dirlist" ]; then
			pm_unlink $dirlist		# JIC
			dirlist=`pm_mktemp dl-${portdir%/*}`
			fetch -q -o - ${sitepath} 2>/dev/null |
			    sed -e "s#%2[cC]#,#g" -e "s#%2[bB]#+#g" > $dirlist
		fi

		for s in ${new_port%\.*} ${new_port%%\.*} ${new_port%-*}; do
			latest_pv=`grep -m1 "href=\"${s}" $dirlist`
			[ -n "$latest_pv" ] && break
		done
	fi
	unset dirlist s

	[ -z "$latest_pv" -a -z "$PM_PACKAGES_LOCAL" ] && {
		fetch_package $new_port try && latest_pv=$new_port; }

	ponly_err="Try --packages-if-newer, or do not use -PP/--packages-only"

	if [ -z "$latest_pv" ]; then
		echo "===>>> Package and/or archive not found at:"
		if [ -n "$LOCAL_PACKAGEDIR" ]; then
			echo "	$LOCAL_PACKAGEDIR"
			[ -z "$PM_PACKAGES_LOCAL" ] && echo '	or'
		fi
		[ -z "$PM_PACKAGES_LOCAL" ] && echo "	${sitepath}"
		echo ''
		echo "       Check the pkg_add(1) man page for information"
		echo "       on setting the PACKAGESITE environment variable"
		[ "$PM_PACKAGES" = only ] && fail $ponly_err
	else
		latest_pv=${latest_pv#*href=\"}
		latest_pv=${latest_pv%%\.tbz*}
	fi

notnewer () {
	echo ''
	echo "===>>> The newest available package ($latest_pv)"
	echo "       is not newer than the installed version ($upg_port)"

	unset local_package
}
	if [ "$latest_pv" = "$new_port" ]; then
		use_package=up_equal
		pm_v "===>>> Available package ($latest_pv) matches the current version"
	elif [ -n "$latest_pv" -a -n "$PM_PACKAGES_NEWER" ]; then
		if [ -n "$upg_port" ]; then
			case `pkg_version -t $upg_port $latest_pv` in
			\<)	use_package=up_newer
				pm_v "===>>> Available package ($latest_pv)"
				pm_v "       is newer than installed ($upg_port)" ;;
			=)	if [ -n "$PM_FORCE" ]; then
					use_package=up_force
				else
					notnewer
				fi ;;
			*)	notnewer ;;
			esac
		else
			use_package=up_no_installed
			pm_v "===>>> There is a package available ($latest_pv)"
		fi
	elif [ -n "$latest_pv" ]; then
		case `pkg_version -t $new_port $latest_pv` in
		\<)	# Could happen if ports tree is out of date
			use_package=up_old_tree
			pm_v "===>>> Available package ($latest_pv)"
			pm_v "       is newer than ports tree ($new_port)" ;;
		=)	;;	# Should not be reached
		*)	# Packages like autoconf-2.1* vs. 2.6* can be false neg.
			fetch_package $new_port try
			if [ $? -eq 0 ]; then
				latest_pv=$new_port
				use_package=up_auto
			else
				echo ''
				echo "===>>> The newest available package ($latest_pv)"
				echo "       is older than the version in ports ($new_port)"
				if [ "$PM_PACKAGES" = only ]; then
					if [ -n "$PM_FORCE" ]; then
						use_package=up_force2
						echo "===>>> Installing anyway due to -f"
					else
						fail $ponly_err
					fi
				fi
			fi ;;
		esac
	fi

	if [ -n "$use_package" ]; then
		new_port=$latest_pv
	else
		if [ "$PM_PACKAGES" = only ]; then
			fail "There is no valid package to install"
		else
			echo ''
			echo "===>>> There is no valid package to install, building port instead"
			echo ''
		fi
	fi
fi	# [ -n "$PM_PACKAGES" -o "$PM_PACKAGES_BUILD" = doing_build_only_dep ]

if [ -z "$use_package" ]; then
	if [ -n "$PM_PACKAGES" ]; then
		[ -z "$PM_NO_MAKE_CONFIG" ] && make_config

		if [ -z "$RECURSE_THOROUGH" ]; then
			echo "===>>> Starting check for build dependencies"
			dependency_check build-depends-list
		fi
	fi

	pm_cd_pd $portdir
	[ -z "$DONT_PRE_CLEAN" ] && { pm_make clean NOCLEANDEPENDS=ncd ||
		fail 'make clean failed'; echo ''; }

	sleep=3
	fl_read=`echo ${TMPDIR}/f-${PM_PARENT_PID}-fetchlog-${portdir#*/}.*`
	while [ -f "$fl_read" ]; do
		echo "===>>> Waiting on fetch & checksum for $portdir <<<==="
		tail -10 $fl_read 2>/dev/null
		echo '' ; echo ''
		sleep $sleep

		if [ $sleep -eq 10 ]; then
			sleep=3
		else
			sleep=$(( $sleep + 1 ))
		fi
	done
	unset sleep fl_read

	if [ -n "$HIDE_BUILD" ]; then
		port_log=`mktemp -t port_log-${PM_PARENT_PID}-${portdir#*/}` ||
			fail "mktemp for $1 failed"
		port_log_args=">> $port_log 2>&1"
		echo "===>>> Logging build to $port_log"
	fi

	[ -n "$PM_NO_MAKE_CONFIG" ] && PM_MAKE_ARGS="$PM_MAKE_ARGS -D_OPTIONS_OK"

	eval pm_make $port_log_args || fail "make failed for $portdir"
else
	[ -z "$local_package" ] && {
		fetch_package $latest_pv || fail "Fetch for ${latest_pv}.tbz failed"; }
fi

# Ignore if no old port exists
if [ -n "$upg_port" -o -n "$ro_upg_port" ]; then
	UPGRADE_PORT="${ro_upg_port:-$upg_port}"
	UPGRADE_PORT_VER=`echo $UPGRADE_PORT | sed 's#.*-\(.*\)#\1#'`
	export UPGRADE_PORT UPGRADE_PORT_VER

	[ -z "$NO_BACKUP" ] && pm_pkg_create $pbu $UPGRADE_PORT

	if [ -n "$SAVE_SHARED" ]; then
		ldconfig_out=`pm_mktemp ldconfig`
		ldconfig -r | sed 's#.* ##' |
		    grep -v ^$LOCALBASE_COMPAT > $ldconfig_out

		unset temp
		for file in `pkg_info -q -L $UPGRADE_PORT |
		    sort - $ldconfig_out | uniq -d`; do
			temp="${temp}$file "
		done
		if [ -n "$temp" ]; then
			if [ ! -d "$LOCALBASE_COMPAT" ]; then
				pm_sv "Creating $LOCALBASE_COMPAT for -w"
				pm_mkdir_s $LOCALBASE_COMPAT
			fi

			pm_sv 'Copying old shared libraries for -w'
			$PM_SU_CMD cp -p $temp ${LOCALBASE_COMPAT}/
			pm_sv Running ldconfig
			$PM_SU_CMD /etc/rc.d/ldconfig start > /dev/null
		fi

		pm_unlink $ldconfig_out ; unset ldconfig_out temp file
	fi

	find_dl_distfiles $portdir

	if [ -n "$REPLACE_ORIGIN" -a -n "$ro_upg_port" ]; then
		# Delete any existing versions of the old port
		pm_sv "Running pkg_delete for $ro_upg_port"
		pm_pkg_delete_s -f $ro_upg_port
	fi

	# Could be empty if -o
	if [ -n "$upg_port" ]; then
		pm_sv "Running pkg_delete for $upg_port"
		pm_pkg_delete_s -f $upg_port
	fi

	pm_cd_pd $portdir
fi

if [ -z "$RECURSE_THOROUGH" -a -z "$NO_DEP_UPDATES" ]; then
	echo '' ; echo "===>>> Starting check for runtime dependencies"
	dependency_check run-depends-list
	pm_cd_pd $portdir
fi

install_failed () {
	local upg_port

	upg_port="${ro_upg_port:-$upg_port}"

	if [ -z "$NO_BACKUP" -a -n "$upg_port" ]; then
		echo ''
		echo "===>>> A backup package for $upg_port should"
		echo "       be located in $pbu"
	fi
	fail "Installation of $1 ($portdir) failed"
}

if [ -z "$use_package" ]; then
	pm_sv Running make install

	if [ -z "$PM_SU_UNSET_PORT_LOG_ARGS" ]; then
		[ -n "$HIDE_BUILD" ] && echo "===>>> Logging install to $port_log"
	else
		unset port_log_args
	fi

	# Defining NO_DEPENDS ensures that we will control the installation
	# of the depends, not bsd.port.mk.
	eval pm_make_s -DNO_DEPENDS install $port_log_args || install_failed $new_port
else
	[ -n "$local_package" ] && ppd=${LOCAL_PACKAGEDIR}/All

	echo "===>>> Installing package"
	if $PM_SU_CMD pkg_add --no-deps --force ${ppd}/${latest_pv}.tbz; then
		if [ -n "$PM_DELETE_PACKAGES" ]; then
			pm_v "===>>> Deleting ${latest_pv}.tbz"
			pm_unlink_s ${ppd}/${latest_pv}.tbz
		fi
	else
		install_failed ${latest_pv}.tbz
	fi
fi
echo ''

[ "$PM_DEL_BUILD_ONLY" = doing_build_only_dep ] &&
	build_deps_il="$build_deps_il $new_port"

# Remove saved libs that match newly installed files

temp=`find $LOCALBASE_COMPAT -type d -empty 2>/dev/null`
if [ -z "$temp" -a -d "$LOCALBASE_COMPAT" ]; then
	unset files
	for file in `pkg_info -q -L $new_port`; do
		[ -f "${LOCALBASE_COMPAT}/${file##*/}" ] &&
			files="${files}${LOCALBASE_COMPAT}/${file##*/} "
	done

	if [ -n "$files" ]; then
		pm_sv Removing old shared libraries, and running ldconfig
		pm_rm_s $files
		$PM_SU_CMD /etc/rc.d/ldconfig start > /dev/null
	fi
	unset temp file files
fi

[ -z "$temp" ] && temp=`find $LOCALBASE_COMPAT -type d -empty 2>/dev/null`
if [ -d "$temp" ]; then
	pm_sv Deleting the empty $LOCALBASE_COMPAT
	pm_rmdir_s $temp
fi
unset temp

# This will serve for *delete*distfiles() as well
[ -z "$use_package" ] && distfiles=`pm_make -V ALLFILES | sed -e 's# *$##g'`
if [ -n "$distfiles" ]; then
	distfiles=" ${distfiles} "

	# Implement storage of distfile information in the way that
	# it will (hopefully, soon?) be implemented in bsd.port.mk
	# See http://www.freebsd.org/cgi/query-pr.cgi?pr=106483
	dist_list=`pm_make_b -V OPTIONSFILE`
	dist_list="${dist_list%options}distfiles"
	if [ ! -d "${dist_list%/distfiles}" ]; then
		pm_sv Creating ${dist_list%/distfiles}
		pm_mkdir_s ${dist_list%/distfiles}
	fi

	ds=`pm_make -V DIST_SUBDIR`
	[ -n "$ds" ] && ds="${ds}/"
	port_subdir="${DISTDIR}${ds}"		# Also for *delete*distfiles()

	if [ -s distinfo ]; then
		distinfo=distinfo
	else
		distinfo=`pm_make -V DISTINFO_FILE`
		[ -n "$distinfo" ] || fail "No DISTINFO_FILE in $portdir"
	fi

	dist_list_temp=`pm_mktemp dist_list`
	echo '# Added by portmaster' > $dist_list_temp
	for file in $distfiles; do
		size=`grep "^SIZE (${ds}${file})" $distinfo`
		sha256=`grep "^SHA256 (${ds}${file})" $distinfo`
		echo "DISTFILE:${ds}${file}:SIZE=${size##* }:SHA256=${sha256##* }" \
		    >> $dist_list_temp
		# Make sure any new distfiles get added to the list
		[ -n "$DI_FILES" -a ! "$$" -eq "$PM_PARENT_PID" ] &&
			echo "${ds}$file" >> $DI_FILES
	done

	pm_sv Installing $dist_list
	pm_install_s $dist_list_temp $dist_list
	pm_unlink $dist_list_temp ; unset ds dist_list_temp
fi

if [ -n "$use_package" ]; then
	if grep -q DEPORIGIN $pdb/$new_port/+CONTENTS; then
		echo "===>>> Updating dependencies for $new_port to match installed versions"
		update_contents $pdb/$new_port/+CONTENTS
		echo ''
	fi
fi

if [ -n "$MAKE_PACKAGE" ]; then
	if [ -z "$use_package" ]; then
		echo "===>>> Creating a package for new version $new_port"
		pm_make_s package >/dev/null || fail "Package creation of $new_port failed"
		echo "	===>>> Package saved to $PACKAGES/All" ; echo ''
	else
		pm_pkg_create $PACKAGES $new_port
	fi
fi

if [ -z "$use_package" -a -z "$DONT_POST_CLEAN" ]; then
	pm_sv Running \'make clean\'
	pm_make_s clean NOCLEANDEPENDS=ncd2
	echo ''
fi

check_dependency_files $portdir $new_port
if [ -s "$grep_deps" ]; then
	echo "===>>> Updating dependency entry for $new_port in each dependent port"; pm_v
	while read d_port; do
		pm_v "===>>> $d_port"
		dp_cont=$pdb/$d_port/+CONTENTS
		[ -e "$dp_cont" ] || continue

		if [ -n "$ro_opd" ]; then
			grep -ql "DEPORIGIN:$ro_opd$" $dp_cont &&
				update_contents $dp_cont $portdir $new_port $ro_opd
		fi
		# Do this one last so it can get deleted as a duplicate
		# if ro_opd is present.
		if grep -ql "DEPORIGIN:$portdir$" $dp_cont; then
			update_contents $dp_cont $portdir $new_port
		fi
	done < $grep_deps
	unset d_port dp_cont do_update

	if [ -e "$pdb/$new_port/+REQUIRED_BY" ]; then
		sort $pdb/$new_port/+REQUIRED_BY | cmp -s $grep_deps - || do_update=do_update
		check_regular_file $pdb/$new_port/+REQUIRED_BY
	else
		do_update=do_update2
	fi
	if [ -n "$do_update" ]; then
		pm_v ; pm_v "	===>>> Updating $new_port/+REQUIRED_BY"
		pm_install_s $grep_deps $pdb/$new_port/+REQUIRED_BY
	fi

	pm_unlink $grep_deps && unset grep_deps do_update
	echo ''
fi

if [ -n "$upg_port" ]; then
	if [ ! "$upg_port" = "$new_port" ]; then
		ilist="Upgrade of $upg_port to $new_port"
	else
		ilist="Re-installation of $upg_port"
	fi
else
	ilist="Installation of $portdir ($new_port)"
fi

if [ "$$" -ne "$PM_PARENT_PID" -o -n "$UPDATE_REQ_BYS" ]; then
	echo "===>>> $ilist succeeded" ; echo ''
fi

INSTALLED_LIST="${INSTALLED_LIST}\t${ilist}\n"
[ -e "$pdb/$new_port/+DISPLAY" ] && DISPLAY_LIST="${DISPLAY_LIST}$new_port "
CUR_DEPS="${CUR_DEPS}${new_port}:${portdir}:"

[ -n "$HIDE_BUILD" -a -n "$port_log" ] && pm_unlink $port_log

[ -n "$URB_YES" -o -n "$UPDATE_REQ_BYS" ] && URB_DONE_LIST="${URB_DONE_LIST}${new_port}:"
[ -n "$URB_YES" -o -n "$UPDATE_REQ_BYS" -o -n "$PM_FORCE" ] &&
	$PM_SU_CMD touch $pdb/$new_port/PM_UPGRADE_DONE_FLAG

if [ -z "$DONT_SCRUB_DISTFILES" ]; then
	delete_stale_distfiles $portdir
	if [ -n "$ro_opd" ]; then
		delete_all_distfiles $ro_opd
		delete_dist_list
	fi
fi

[ -n "$UPDATE_REQ_BYS" -a -s "$pdb/$new_port/+REQUIRED_BY" ] && urb_final

safe_exit

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#  Copyright (c) 2005-2011 Douglas Barton
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
#  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
#  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
#  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#  SUCH DAMAGE.
